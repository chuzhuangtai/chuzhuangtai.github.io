<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F2018%2F03%2F06%2FHello-World%2F</url>
    <content type="text"><![CDATA[动画与变形动画原理 动画的原理，就是一张张画面连续快速播放，当速度超过每秒24张时，人的肉眼就不会分辨出卡顿感。而觉得是在播放连续的视频动画 所以， 我们要实现动画，只需要隔十几毫秒把屏幕清空之后，重新绘制下一帧就可以了 执行动画方案 我们可以用window.setInterval(), window.setTimeout(),和window.requestAnimationFrame()来设定定期执行一个指定函数。 setInterval(function, delay): 当设定好间隔时间后，function会定期执行。 setTimeout(function, delay): 在设定好的时间之后执行函数 requestAnimationFrame(callback): 递归调用的形式才实现动画，动画的频率跟随浏览器的刷新频率，效率比较高，连续动画都使用这种方式就可以了 弹球动画讲解 先实现绘制某一帧的方法(draw()) 清空canvas 绘制小球 更改小球的位置 添加一个动画(window.requesAnimationFrame(draw)) 边界处理 如果小球到达边界，修改其速度为反方向； 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;script&gt; var canvas = document.getElementById("canvas"); var ctx = canvas.getContext("2d"); ctx.fillStyle = "blue"; var animation; //创建一个圆对象 var circle = &#123; radias: 30, x: 0, y: 0, speedx: 2, speedy: 1, isRunning: false, draw: function () &#123; //画一个圆 ctx.beginPath(); ctx.arc(this.x, this.y, this.radias, 0, 2*Math.PI); ctx.fill(); &#125; &#125;; function draw() &#123; //每一帧，圆的位置都会发生变化 circle.x += circle.speedx; circle.y += circle.speedy; //边界判断，到了边界就调头 if (circle.x == canvas.width-circle.radias || circle.x == circle.radias) &#123; circle.speedx = -circle.speedx; &#125; if (circle.y == canvas.height-circle.radias || circle.y == circle.radias) &#123; circle.speedy = -circle.speedy; &#125; //绘制小球，绘制当前帧，把上一帧的画面清空 //ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.save(); ctx.fillStyle = "rgba(255,255,255,0.2)"; //ctx.fillStyle = "red"; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore(); circle.draw(); //开始执行动画 animation = window.requestAnimationFrame(draw); &#125; //添加点击事件，当点击时，如果正在运行，则暂停，如果没有正在运行，则点击动行 canvas.addEventListener("click", function (e) &#123; if (!circle.isRunning) &#123; circle.x = e.clientX; circle.y = e.clientY; animation = window.requestAnimationFrame(draw); circle.isRunning = true; &#125; else &#123; circle.isRunning = false; window.cancelAnimationFrame(animation); &#125; &#125;);&lt;/script&gt; 变形缩放 scale是用来缩放画布元素的坐标和宽高。如果一张（100*100）的画布，scale为（0.5, 0.5），用fillRect(50, 50, 50, 50)来画一个正方形，实际显示效果未缩放前的（25, 25, 25, 25）位置和大小的效果是一样的。 代码与示例 1234567891011121314151617181920212223&lt;script&gt; var canvas = document.getElementById("canvas"); var ctx = canvas.getContext("2d"); //设置画笔的粗细和颜色 ctx.lineWidth = 1; ctx.strokeStyle = "red"; //1. 将画笔移动到某个点 ctx.moveTo(0, 200); //2. 从上面这个点开始，划一条直接到某一个点 ctx.lineTo(600, 200); ctx.moveTo(300, 0); ctx.lineTo(300, 400); //3. 填充颜色 ctx.stroke(); ctx.fillRect(300, 200, 100, 100); ctx.scale(0.5, 0.5); ctx.fillRect(300, 200, 100, 100);&lt;/script&gt; 平移 平移就是改变往水平或垂直方向，改变参考原点的值。translate(100, 100);就是绘图时，在当前参考原点的基本之上，向右平移100像素，向下平移100像素。 代码与示例 1234567891011121314151617181920212223&lt;script&gt; var canvas = document.getElementById("canvas"); var ctx = canvas.getContext("2d"); //设置画笔的粗细和颜色 ctx.lineWidth = 1; ctx.strokeStyle = "red"; //1. 将画笔移动到某个点 ctx.moveTo(0, 200); //2. 从上面这个点开始，划一条直接到某一个点 ctx.lineTo(600, 200); ctx.moveTo(300, 0); ctx.lineTo(300, 400); //3. 填充颜色 ctx.stroke(); ctx.fillRect(300, 200, 100, 100); ctx.translate(100, 100); ctx.fillRect(300, 200, 100, 100);&lt;/script&gt; 旋转 旋转，就是围绕当前的原点，坐标系发生旋转。 代码与示例 12345678910111213141516171819&lt;script&gt; var canvas = document.getElementById("canvas"); var ctx = canvas.getContext("2d"); ctx.save(); ctx.translate(200, 200); //画30条直线，角度不一样 for (var i=0; i&lt;30; i++) &#123; ctx.rotate(1/15*Math.PI); ctx.beginPath(); ctx.moveTo(30, 0); ctx.lineTo(150, 0); ctx.stroke(); &#125; ctx.restore();&lt;/script&gt; ​]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ]]></title>
    <url>%2F2018%2F03%2F06%2FActiveMQ%2F</url>
    <content type="text"><![CDATA[ActiveMQ简单的示例下载ActiveMQ 去官方网站下载：http://activemq.apache.org/ 运行ActiveMQ 解压缩apache-activemq-5.9.0-bin.zip， 修改配置文件activeMQ.xml，将0.0.0.0修改为localhost 123456789&lt;transportConnector name="openwire" uri="tcp://localhost:61616"/&gt;&lt;transportConnector name="ssl" uri="ssl://localhost:61617"/&gt;&lt;transportConnector name="stomp" uri="stomp://localhost:61613"/&gt;&lt;transportConnector uri="http://localhost:8081"/&gt;&lt;transportConnector uri="udp://localhost:61618"/&gt; 然后双击apache-activemq-5.9.0\bin\activemq.bat运行ActiveMQ程序。 启动ActiveMQ以后，登陆：http://localhost:8161/admin/ 账号密码：admin 创建一个Queue，命名为FirstQueue。 点对点 即一个生产者和一个消费者一一对应 producer生产者12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) throws Exception &#123; // 1. 创建连接工厂ActiveMQConnectionFactory，需要ip和端口61616 ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://192.168.37.161:61616"); // 2. 从连接工厂中创建连接对象 Connection connection = factory.createConnection(); // 3. 执行start方法开启连接 connection.start(); // 4. 从连接中创建session对象 // 第一个参数，是否开启事务，JTA分布式事务 // 第二个参数，是否自动应答，如果第一个参数为true，第二个参数失效 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 5. 从session中创建Destination对象，设置queue名称（有两种类型queue和topic） Queue queue = session.createQueue("test-queue"); // 6. 从session中创建Product对象 MessageProducer producer = session.createProducer(queue); // 7. 创建消息对象 TextMessage textMessage = new ActiveMQTextMessage(); // 设置消息内容 textMessage.setText("开始发消息！"); // 8. 发送消息 producer.send(textMessage); // 9. 关闭session、连接 producer.close(); session.close(); connection.close(); &#125; consumer消费者 直接获取消息 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) throws Exception &#123; // 1. 创建连接工厂ActiveMQConnectionFactory，需要ip和端口61616 ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://192.168.37.161:61616"); // 2. 使用工厂创建连接 Connection connection = factory.createConnection(); // 3. 使用start开启连接 connection.start(); // 4. 从连接中创建session对象 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 5. 从session中创建Destination对象，设置queue名字 Queue queue = session.createQueue("test-queue"); // 6. 从session中创建Consumer MessageConsumer consumer = session.createConsumer(queue); // 7， 接收消息,直接获取 while (true) &#123; // 消息超时时间是20秒 Message message = consumer.receive(20000); // 如果消息为空，则跳出死循环 if (message == null) &#123; break; &#125; // 8. 打印消息 if (message instanceof TextMessage) &#123; // 获取消息 TextMessage textMessage = (TextMessage) message; // 打印 System.out.println(textMessage.getText()); &#125; &#125; // 9. 关闭session、连接等 consumer.close(); session.close(); connection.close(); &#125; ​ 使用监听器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public static void main(String[] args) throws Exception &#123; // 1. 创建连接工厂ActiveMQConnectionFactory，需要ip和端口61616 ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://192.168.37.161:61616"); // 2. 使用工厂创建连接 Connection connection = factory.createConnection(); // 3. 使用start开启连接 connection.start(); // 4. 从连接中创建session对象 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 5. 从session中创建Destination对象，设置queue名字 Queue queue = session.createQueue("test-queue"); // 6. 从session中创建Consumer MessageConsumer consumer = session.createConsumer(queue); // // 7， 接收消息,直接获取 // while (true) &#123; // // 消息超时时间是20秒 // Message message = consumer.receive(20000); // // 如果消息为空，则跳出死循环 // if (message == null) &#123; // break; // &#125; // // // 8. 打印消息 // if (true) &#123; // if (message instanceof TextMessage) &#123; // // 获取消息 // TextMessage textMessage = (TextMessage) message; // // 打印 // System.out.println(textMessage.getText()); // &#125; // &#125; // &#125; // 7.接收消息 // 监听器的方式实际上是开启了一个新的线程，专门处理消息的接受 // 现在的情况是，主线程执行完就结束了，新的线程也跟着没了 consumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; if (message instanceof TextMessage) &#123; // 获取消息 TextMessage textMessage = (TextMessage) message; try &#123; // 打印 System.out.println(textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;); // 让主线程等待一会，监听器能够有时间执行 Thread.sleep(10000); // 9. 关闭session、连接等 consumer.close(); session.close(); connection.close(); &#125; ​ 发布/订阅模式 即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。 producer生产者12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) throws Exception &#123; // 1. 创建连接工厂ActiveMQConnectionFactory ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory( "tcp://192.168.37.161:61616"); // 2. 使用工厂创建连接 Connection connection = activeMQConnectionFactory.createConnection(); // 3. 使用start方法开启连接 connection.start(); // 4. 从连接创建session Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 5. 从session创建Destination对象，设置topic名称 Topic topic = session.createTopic("test-topic"); // 6. 从session创建Product MessageProducer producer = session.createProducer(topic); // 7. 创建消息对象 TextMessage textMessage = new ActiveMQTextMessage(); textMessage.setText("topic消息"); // 8. 发送消息 producer.send(textMessage); // 9. 关闭session、连接等 producer.close(); session.close(); connection.close(); &#125;&#125; consumer消费者 consumer1 1234567891011121314151617181920212223242526272829303132333435363738394041public static void main(String[] args) throws Exception &#123; // 1. 创建连接工厂ActiveMQConnectionFactory ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory( "tcp://192.168.37.161:61616"); // 2. 从连接工厂创建连接 Connection connection = activeMQConnectionFactory.createConnection(); // 3. 使用start方法开启连接 connection.start(); // 4. 从连接创建session对象 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 5. 从session创建安Destination，设置topic名称 Topic topic = session.createTopic("test-topic"); // 6. 从session创建Consumer对象 MessageConsumer consumer = session.createConsumer(topic); // 7. 接收消息，直接接受 while (true) &#123; Message message = consumer.receive(20000); if (message == null) &#123; break; &#125; if (message instanceof TextMessage) &#123; TextMessage textMessage = (TextMessage) message; // 8. 打印消息 System.out.println(textMessage.getText()); &#125; &#125; // 9. 关闭session、消息等 consumer.close(); session.close(); connection.close(); &#125; consumer2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public static void main(String[] args) throws Exception &#123; // 1. 创建连接工厂ActiveMQConnectionFactory ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory( "tcp://192.168.37.161:61616"); // 2. 从连接工厂创建连接 Connection connection = activeMQConnectionFactory.createConnection(); // 3. 使用start方法开启连接 connection.start(); // 4. 从连接创建session对象 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 5. 从session创建安Destination，设置topic名称 Topic topic = session.createTopic("test-topic"); // 6. 从session创建Consumer对象 MessageConsumer consumer = session.createConsumer(topic); // 7. 接收消息，直接接受 // while (true) &#123; // Message message = consumer.receive(20000); // // if (message == null) &#123; // break; // &#125; // // if (message instanceof TextMessage) &#123; // TextMessage textMessage = (TextMessage) message; // // 8. 打印消息 // System.out.println(textMessage.getText()); // &#125; // &#125; // 7.接受消息，使用监听器 consumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; if (message instanceof TextMessage) &#123; TextMessage textMessage = (TextMessage) message; try &#123; // 打印消息 System.out.println(textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;); // 等待监听器执行 Thread.sleep(10000); // 9. 关闭session、消息等 consumer.close(); session.close(); connection.close(); &#125; 整合spring加入依赖1234567891011121314151617&lt;!-- 加入ActiveMQ依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 加入spring-jms依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Spring --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;&lt;/dependency&gt; 消息发送1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123;// 1. 创建spring容器ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext-activemq.xml");// 2. 从容器中获取JMSTemplate对象JmsTemplate jmsTemplate = context.getBean(JmsTemplate.class);// 3. 从容器中获取Destination对象Destination destination = context.getBean(Destination.class);// 4. 使用JMSTemplate发送消息jmsTemplate.send(destination, new MessageCreator() &#123;@Overridepublic Message createMessage(Session session) throws JMSException &#123;// 创建消息对象TextMessage textMessage = new ActiveMQTextMessage();// 设置消息内容textMessage.setText("spring整合ActiveMQ");// 打印消息System.out.println(textMessage.getText());return textMessage;&#125;&#125;);&#125; 消息接收1234567891011121314151617181920212223public class MyMessageListener implements MessageListener &#123;@Overridepublic void onMessage(Message message) &#123;if (message instanceof TextMessage) &#123;TextMessage textMessage = (TextMessage) message;try &#123;// 获取消息内容String msg = textMessage.getText();// 打印消息System.out.println("接受消息:" + msg);&#125; catch (JMSException e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125;&#125;&#125;&#125; queue方式配置spring1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jms="http://www.springframework.org/schema/jms" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.37.161:61616" /&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory" /&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 --&gt; &lt;bean id="queueDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg&gt; &lt;value&gt;queue&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!--这个是主题目的地，一对多的 --&gt; &lt;!-- &lt;bean id="topicDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; --&gt; &lt;!-- &lt;constructor-arg value="topic" /&gt; --&gt; &lt;!-- &lt;/bean&gt; --&gt; &lt;!-- messageListener实现类 --&gt; &lt;bean id="myMessageListener" class="cn.itcast.activemq.spring.MyMessageListener"&gt;&lt;/bean&gt; &lt;!-- 配置一个jsm监听容器 --&gt; &lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="queueDestination" /&gt; &lt;property name="messageListener" ref="myMessageListener" /&gt; &lt;/bean&gt;&lt;/beans&gt; topic方式配置spring1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jms="http://www.springframework.org/schema/jms" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.37.161:61616" /&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory" /&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 --&gt; &lt;!-- &lt;bean id="queueDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; --&gt; &lt;!-- &lt;constructor-arg&gt; --&gt; &lt;!-- &lt;value&gt;queue&lt;/value&gt; --&gt; &lt;!-- &lt;/constructor-arg&gt; --&gt; &lt;!-- &lt;/bean&gt; --&gt; &lt;!--这个是主题目的地，一对多的 --&gt; &lt;bean id="topicDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="topic" /&gt; &lt;/bean&gt; &lt;!-- messageListener实现类 --&gt; &lt;bean id="myMessageListener" class="cn.itcast.activemq.spring.MyMessageListener"&gt;&lt;/bean&gt; &lt;!-- messageListener实现类 --&gt; &lt;bean id="myMessageListener2" class="cn.itcast.activemq.spring.MyMessageListener2"&gt;&lt;/bean&gt; &lt;!-- 配置一个jsm监听容器 --&gt; &lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="topicDestination" /&gt; &lt;property name="messageListener" ref="myMessageListener" /&gt; &lt;/bean&gt; &lt;!-- 配置一个jsm监听容器 --&gt; &lt;bean id="jmsContainer2" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="topicDestination" /&gt; &lt;property name="messageListener" ref="myMessageListener2" /&gt; &lt;/bean&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JMS</tag>
        <tag>MQ</tag>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
</search>
