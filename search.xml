<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F07%2Fnodejs%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[文件模块：读写文件 var fs = require(‘fs’); 路径模块：拼接路径 var path = require(‘path’); url模块：解析url路径得到url协议中的每一部分 var url = require(‘url’); 使用url模块解析请求路径: 第一个参数：要解析的字符串 第二个参数：boolean 如果为true则query是一个对象 如果为false则query是一个字符串 返回值是一个url对象，本质就是将req.url拆分成url协议的完整结构，得到一个url对象 protocol: null,//协议名 slashes: null,//表示 //到第一个/之间都是host auth: null,//认证 host: null,//主机名+ 端口号 hosetname+port port: null,//端口号 hostname: null,//主机名 ip地址 hash: null,//资源定位符 search: ‘?name=OldFe&amp;age=18’, query: { name: ‘OldFe’, age: ‘18’ },//get请求的参数对象 pathname: ‘/getRequest’,//路径 path: ‘/getRequest?name=OldFe&amp;age=18’,//路径+请求参数 href: ‘/getRequest?name=OldFe&amp;age=18’ } querystring模块：解析post请求的参数var querystring = require(‘querystring’); end函数只能有两种参数字符串和二进制需要将json对象转为字符串响应返回res.end()是nodejs原生的响应请求的API 它的参数只能是字符串或者二进制，如果是json对象需要自己去转json字符串 //express它拓展了几个响应请求的API //res.send(普通文本)自动转中文 //res.json(json对象)自动将json对象转为json字符串]]></content>
  </entry>
  <entry>
    <title><![CDATA[模板引擎]]></title>
    <url>%2F2018%2F04%2F05%2F%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[模板引擎渲染的本质 只是字符串的替换 使用js语言实现字符串的替换 只要有js语言都可以做模板引擎渲染，模板引擎渲染并不一定只在客户端完成客户端模板引擎用法 （1）导入art-template （2） ajax请求模板数据 （3）写模板（script标签中 text属性不能是javascript）&lt;script typr=&quot;text/html&quot; id=&quot;xx&quot;&gt;&lt;/script&gt; （4）模板引擎渲染 template(模板id，数据) express配置模板引擎 配置模板引擎用法 express中的模板引擎：默认情况下express中的模板引擎是jade第三方 模板引擎的第三方有很多种，有十几种，art-template只是其中一种 如果想用自己的模板引擎，则需要去对应的模板引擎官网查看如何配置express art-template：http://aui.github.io/art-template/express/ 1.先下载第三方模块，需要下载两个 npm install --save art-template npm install --save express-art-template 2.配置模板引擎：两行代码 app.engine(&#39;html&#39;,require(&#39;express-art-template&#39;)) 第一个参数：模板文件的后缀名，一般为html 第二个参数：要配置的第三方模块，不要修改直接从官网复制粘贴 app.set(&#39;view engine&#39;,&#39;html&#39;) 第一个参数：固定字符串 view engine:模板引擎 第二个参数：与第一行代码的第一个参数一致即可 一旦配置模板引擎之后，所有的res对象都会添加一个render函数，这就是模板引擎渲染函数 3.使用模板引擎：res.render(&#39;模板文件名&#39;,&#39;要渲染的数据&#39;) 第一个参数：要渲染的模板文件名 默认情况下express只会从views文件夹下寻找模板文件 views是服务端MVC的V层文件夹标准叫法 第二个参数：要渲染的数据 只能是json对象，如果为空则直接响应返回html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>模板引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2018%2F03%2F12%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包 闭包就是能够读取其他函数内部变量的函数。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 闭包的作用 让函数外可以访问函数内成员 让函数内成员始终活在内存中，生命周期延长。 解决变量污染（只读不改）面向对象封装思想 减少变量声明 控制某些数据访问权限（过滤非法数据） 闭包不能滥用，否则会导致内存泄露，影响网页的性能。闭包使用完了后，要立即释放资源，将引用变量指向null。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas动画]]></title>
    <url>%2F2018%2F03%2F01%2FCanvas%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[动画与变形动画原理 动画的原理，就是一张张画面连续快速播放，当速度超过每秒24张时，人的肉眼就不会分辨出卡顿感。而觉得是在播放连续的视频动画 所以， 我们要实现动画，只需要隔十几毫秒把屏幕清空之后，重新绘制下一帧就可以了 执行动画方案 我们可以用window.setInterval(), window.setTimeout(),和window.requestAnimationFrame()来设定定期执行一个指定函数。 setInterval(function, delay): 当设定好间隔时间后，function会定期执行。 setTimeout(function, delay): 在设定好的时间之后执行函数 requestAnimationFrame(callback): 递归调用的形式才实现动画，动画的频率跟随浏览器的刷新频率，效率比较高，连续动画都使用这种方式就可以了 弹球动画讲解 先实现绘制某一帧的方法(draw()) 清空canvas 绘制小球 更改小球的位置 添加一个动画(window.requesAnimationFrame(draw)) 边界处理 如果小球到达边界，修改其速度为反方向； 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;script&gt; var canvas = document.getElementById("canvas"); var ctx = canvas.getContext("2d"); ctx.fillStyle = "blue"; var animation; //创建一个圆对象 var circle = &#123; radias: 30, x: 0, y: 0, speedx: 2, speedy: 1, isRunning: false, draw: function () &#123; //画一个圆 ctx.beginPath(); ctx.arc(this.x, this.y, this.radias, 0, 2*Math.PI); ctx.fill(); &#125; &#125;; function draw() &#123; //每一帧，圆的位置都会发生变化 circle.x += circle.speedx; circle.y += circle.speedy; //边界判断，到了边界就调头 if (circle.x == canvas.width-circle.radias || circle.x == circle.radias) &#123; circle.speedx = -circle.speedx; &#125; if (circle.y == canvas.height-circle.radias || circle.y == circle.radias) &#123; circle.speedy = -circle.speedy; &#125; //绘制小球，绘制当前帧，把上一帧的画面清空 //ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.save(); ctx.fillStyle = "rgba(255,255,255,0.2)"; //ctx.fillStyle = "red"; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore(); circle.draw(); //开始执行动画 animation = window.requestAnimationFrame(draw); &#125; //添加点击事件，当点击时，如果正在运行，则暂停，如果没有正在运行，则点击动行 canvas.addEventListener("click", function (e) &#123; if (!circle.isRunning) &#123; circle.x = e.clientX; circle.y = e.clientY; animation = window.requestAnimationFrame(draw); circle.isRunning = true; &#125; else &#123; circle.isRunning = false; window.cancelAnimationFrame(animation); &#125; &#125;);&lt;/script&gt; 变形缩放 scale是用来缩放画布元素的坐标和宽高。如果一张（100*100）的画布，scale为（0.5, 0.5），用fillRect(50, 50, 50, 50)来画一个正方形，实际显示效果未缩放前的（25, 25, 25, 25）位置和大小的效果是一样的。 代码与示例 1234567891011121314151617181920212223&lt;script&gt; var canvas = document.getElementById("canvas"); var ctx = canvas.getContext("2d"); //设置画笔的粗细和颜色 ctx.lineWidth = 1; ctx.strokeStyle = "red"; //1. 将画笔移动到某个点 ctx.moveTo(0, 200); //2. 从上面这个点开始，划一条直接到某一个点 ctx.lineTo(600, 200); ctx.moveTo(300, 0); ctx.lineTo(300, 400); //3. 填充颜色 ctx.stroke(); ctx.fillRect(300, 200, 100, 100); ctx.scale(0.5, 0.5); ctx.fillRect(300, 200, 100, 100);&lt;/script&gt; 平移 平移就是改变往水平或垂直方向，改变参考原点的值。translate(100, 100);就是绘图时，在当前参考原点的基本之上，向右平移100像素，向下平移100像素。 代码与示例 1234567891011121314151617181920212223&lt;script&gt; var canvas = document.getElementById("canvas"); var ctx = canvas.getContext("2d"); //设置画笔的粗细和颜色 ctx.lineWidth = 1; ctx.strokeStyle = "red"; //1. 将画笔移动到某个点 ctx.moveTo(0, 200); //2. 从上面这个点开始，划一条直接到某一个点 ctx.lineTo(600, 200); ctx.moveTo(300, 0); ctx.lineTo(300, 400); //3. 填充颜色 ctx.stroke(); ctx.fillRect(300, 200, 100, 100); ctx.translate(100, 100); ctx.fillRect(300, 200, 100, 100);&lt;/script&gt; 旋转 旋转，就是围绕当前的原点，坐标系发生旋转。 代码与示例 12345678910111213141516171819&lt;script&gt; var canvas = document.getElementById("canvas"); var ctx = canvas.getContext("2d"); ctx.save(); ctx.translate(200, 200); //画30条直线，角度不一样 for (var i=0; i&lt;30; i++) &#123; ctx.rotate(1/15*Math.PI); ctx.beginPath(); ctx.moveTo(30, 0); ctx.lineTo(150, 0); ctx.stroke(); &#125; ctx.restore();&lt;/script&gt; ​]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化总结]]></title>
    <url>%2F2018%2F02%2F26%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[性能优化总结1. 减少http请求​ 减少http的主要手段是合并CSS、合并javascript、合并图片。将浏览器一次访问需要的javascript和CSS合并成一个文件，这样浏览器就只需要一次请求。图片也可以合并，多张图片合并成一张。如果每张图片都有不同的超链接，可通过CSS偏移响应鼠标点击操作，构造不同的URL。 2. 使用浏览器缓存​ 对一个网站而言，CSS、javascript、logo、图标这些静态资源文件更新的频率都比较低，而这些文件又几乎是每次http请求都需要的，如果将这些文件缓存在浏览器中，可以极好的改善性能。 ​ 可以使用localStorage来存储数据。 3. CSS放在页面最上部，javascript放在页面最下面​ 浏览器会在下载完成全部CSS之后才对整个页面进行渲染，因此最好的做法是将CSS放在页面最上面，让浏览器尽快下载CSS。如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕，所以可以考虑将CSS放在HEAD中。 ​ Javascript则相反，浏览器在加载javascript后立即执行，有可能会阻塞整个页面，造成页面显示缓慢，因此javascript最好放在页面最下面。但如果页面解析时就需要用到javascript，这时放到底部就不合适了，不过这时候可以写入口函数，让这段js代码在程序运行最开始调用。 3. 避免页面跳转​ 可以使用ajax进行无刷新和后台交互，利用js来发送请求报文。阻止a标签默认事件。 4. 对图片进行优化 图片懒加载 小图片可以做成精灵图，或字体图标 加载完成前先准备一张压缩的特别厉害的缩略图，提高用户体验 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。 ​]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式viewport设计]]></title>
    <url>%2F2018%2F01%2F14%2Fviewport%2F</url>
    <content type="text"><![CDATA[响应式viewport设计什么是 Viewport?viewport 是用户网页的可视区域。 viewport 翻译为中文可以叫做”视区”。 在移动设备里面， 屏幕可以把它相像成一个窗户。 网页是在窗户的后面一个叫做 视区（viewport）的区域显示的。 就相当于在窗记的后面有一块可以滑动的幕布。 一般情况下， viewport的宽度，会比手机的实际的宽度要大。 viewport的背景： 在智能手机才出来的时候，所有的pc端的网页，要想在手机上完整显示， 必须只能左右滑动。 这样的话只能让手机的可视区。比手机屏幕的宽度要大。 就产生了一个问题： 在布局的时候，如果使用百分比布局，参考的屏幕的宽度可能是一个错误的值。 强制去设置视口的宽度和屏幕的宽度一致。 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; viewport的属性的介绍 height：和 width 相对应，指定高度。 initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。 maximum-scale：允许用户缩放到的最大比例。 minimum-scale：允许用户缩放到的最小比例。 user-scalable：用户是否可以手动缩放。]]></content>
      <categories>
        <category>web移动端</category>
      </categories>
      <tags>
        <tag>viewport设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的本地保存用法总结]]></title>
    <url>%2F2018%2F01%2F09%2F%E6%9C%AC%E5%9C%B0%E4%BF%9D%E5%AD%98%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[JS的本地保存用法总结localStorage和sessionStorage的区别 JS中为了减少与服务器的通信，经常会用到保存的数据到本地的功能，例如本地用户信息保存。 1. localStorage和sessionStorage一样都是用来存储客户端临时信息的对象。 2. 他们均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现）。 3. localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了 4. 不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。 localStorage、和sessionStorage的用法123456789101112131415161718192021localStorage和sessionStorage使用时使用相同的API：localStorage.setItem(&quot;key&quot;,&quot;value&quot;);//以“key”为名称存储一个值“value”localStorage.getItem(&quot;key&quot;);//获取名称为“key”的值列举localStorage的方法：for(var i=0;i&lt;localStorage.length;i++)&#123; var name = localStorage.key(i); var value = localStorage.getItem(name);&#125;删除localStorage中存储信息的方法：localStorage.removeItem(&quot;key&quot;);//删除名称为“key”的信息。localStorage.clear();//清空localStorage中所有信息]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>本地存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒子拖拽]]></title>
    <url>%2F2017%2F12%2F20%2F%E6%8B%96%E6%8B%BD%2F</url>
    <content type="text"><![CDATA[拖拽拖拽事件 要想让一个元素可以被拖拽，需要设置其 draggable=”true” 被拖拽的子元素，可以实现以下事件： ondragstart： 拖拽开始 ondrag：拖拽中 ondragend： 拖拽结束 ondragleave： 离开父盒子 ondrop: 松手 对被拖入子元素的父盒子 ondragover： 经过父盒子 ondragenter： 进入父盒子示例 将红色方块从第一个盒子移入第二个盒子中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;style&gt; .box1, .box2 &#123; width: 800px; height: 200px; background-color: yellowgreen; &#125; .littleBox &#123; width: 100px; height: 100px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;第一个盒子&lt;/h3&gt; &lt;div class="box1"&gt; &lt;div class="littleBox" draggable="true"&gt;&lt;/div&gt; &lt;/div&gt; &lt;h3&gt;第二个盒子&lt;/h3&gt; &lt;div class="box2"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; var littleBox = document.querySelector(".littleBox"); var beginBox = document.querySelector(".box1"); var endBox = document.querySelector(".box2"); //开始拖拽 littleBox.ondragstart = function () &#123; console.log("开始拖拽"); &#125; //拖拽中 littleBox.ondrag = function () &#123; console.log("正在拖拽"); &#125; //拖拽结束 littleBox.ondragend = function () &#123; console.log("结束拖拽"); &#125; //离开父盒子 littleBox.ondragleave = function () &#123; console.log("离开父盒子"); &#125; //为下面的盒子绑定拖入事件 //默认是不允许拖入的， 修改默认值 endBox.ondragover = function (event) &#123; //阻止默认行为 event.preventDefault(); &#125; endBox.ondragenter = function () &#123; console.log("进入"); &#125; endBox.ondrop = function () &#123; console.log("松手"); this.appendChild(littleBox); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[会话技术]]></title>
    <url>%2F2017%2F10%2F13%2F%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[会话技术cookiecookie原理分析 一个cookie的设置以及发送过程分为以下四步 客户端发送一个http请求到服务器端 服务器端发送一个http响应到客户端，其中包含Set-Cookie头部 客户端发送一个http请求到服务器端，其中包含Cookie头部 服务器端发送一个http响应到客户端 cookie常用属性 expires 有效期 path 路径 domain 域名 服务器操作cookie12345678// 设置cookie// setcookie(name, value, expire, path, domain);// 设置1小时后过期setcookie("user", "lisi", time()+3600);// 获取单个cookieecho $_COOKIE["user"];// 查看所有cookieprint_r($_COOKIE); js对cookie基本操作1234567891011121314151617// 设置cookiefunction setCookie(key,value,param)&#123; document.cookie = key + '=' + value + '; expires=' + param.expires + '; path=' + param.path; &#125;// 获取cookiefunction getCookie(key)&#123; var cookies = document.cookie; var arr = cookies.split('; '); if(arr)&#123; for (var i = 0; i &lt; arr.length; i++) &#123; var kv = arr[i].split('='); if(kv[0] == key)&#123; return kv[1]; &#125; &#125; &#125;&#125; jQuery插件操作cookie（jquery.cookie.js） cookie插件基本使用 设置单个cookie 获取单个cookie 获取所有cookie 删除单个cookie 浏览器中cookie基本设置 sessionsession原理分析 客户端第一次请求服务器时，服务器开启一个session，生成一个唯一标识（sessionid：存储的数据与此sessionid关联），并以响应头的Set-Cookie属性响应到客户端 客户端的后续请求会一直通过请求头的Cookie属性携带sessionid（客户端与服务器通过此id维持状态） session基本操作 设置session 12session_start();$_SESSION['user'] = array('username'=&gt;'lisi','age'=&gt;'12'); 读取session 12session_start();$user = $_SESSION['user']; 删除一个session信息 12session_start();unset($_SESSION['user']); 删除所有session信息 12session_start();unset($_SESSION); 销毁session 1session_destroy(); session与cookie的关系 session可以借助cookie实现状态维持，也可以不依赖cookie（URL重写） 区别 cookie session 存储位置 浏览器 服务器 浏览器携带的数据量 多 少（只携带session-id） 存储的数据类型 只能是字符串 任意类型 安全性 较低 较高 默认的有效路径 当前路径及其子路径 整站有效 数据的传输量 有限制4K，不能超过20个 无限制 总结cookie就是一种保存数据的技术，保存的位置是浏览器。 只能够保存字符串。 不能保存复杂类型。 可以随意修改，因为我们能在浏览器看到cookie保存的内容。 一般是作为登录的判断 cookie的生命周期很短，默认是一次会话。关闭浏览器就会被销毁 session就是一种保存数据的技术，保存的位置是服务器。 可以保存复杂数据类型。 浏览器中看不到数据 生命周期长]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>会话技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs中的get和post]]></title>
    <url>%2F2017%2F09%2F29%2Fnodejs%E4%B8%ADgit%E5%92%8Cpost%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Nodejs中的get和post请求参数GET请求：url模块：解析url路径得到url协议中的每一部分 var url = require(&#39;url&#39;); 使用url模块解析请求路径: 第一个参数：要解析的字符串 第二个参数：boolean 如果为true则query是一个对象 如果为false则query是一个字符串 //返回值是一个url对象，本质就是将req.url拆分成url协议的完整结构，得到一个url对象 var urlObjc = url.parse(req.url,true); get请求的参数就是这个对象的query属性 POST请求： nodejs接收post请求参数 post请求的参数是在请求体中，无法使用get的方式来接收post请求的参数 post请求的特点：post请求的参数无法一次获取，有可能是多次 原因：post可以提交大数据，而宽带有网络限制 nodejs接收post请求参数的流程 ​ var postData = &quot;&quot;; 给req对象注册一个data事件：表示开始接收post请求参数 ​ 客户端没发送一次数据该方法都会执行一次，回调函数的参数就是本次接收到的数据（数据流） ​ 接受的次数不固定：取决于数据的大小和你的宽带的网速 req.on(&apos;data&apos;, function (chuck) { postData += chuck; }); 给requ对象注册一个end事件，表示本次post数据发送完毕​​ ​ req.on(‘end’, function () { //post接收到的数据其实就是url完整结构中的query部分 console.log(postData); ​ } 解析post参数得到参数对象 ​ 无法使用url模块的pares函数来解析，因为这个函数解析的是url的完整结构 ​ 而post数据接收到的只是query部分 ​ 使用querystring模块来解析post请求的参数 ​ var postObjc = querystring.parse(postData);]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP数据库简单操作]]></title>
    <url>%2F2017%2F09%2F27%2FPHP%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[数据库操作方式 图形界面客户端 创建连接 创建数据库 删除数据库 创建表 编辑表 删除表 表结构分析 数据类型分析 数据增删改查操作 SQL SQL基本概述 插入数据insert 12-- insert into 表名 (字段列表) values (值列表)insert into book (name,author,category,price) values ('天龙八部','金庸','文学',20) 修改数据update 12-- update 表名 set 字段名称1=值1,字段名称2=值2,... where 条件update book set name='笑傲江湖',price='30' where id=10 删除数据delete 12-- delete from 表名 where 条件delete from book where id=10 查询数据select 12-- select * from 表名 where 条件select * from book where author='金庸' and price&gt;20 简单的联表查询 1select u.username,b.name from user u,book b where u.id=b.uid and b.price&gt;20 PHP代码操作数据 连接数据库基本步骤 12345678910111213141516171819// 1、连接数据库$server = 'localhost';//数据库所在计算机的域名或者IP地址$username = 'root';//登录数据库的用户名$pw = '';//登录数据库的密码// 执行连接操作$link = mysql_connect($server,$username,$pw);// 2、选择要操作哪个数据库mysql_select_db('hello',$link);// 3、设置查询编码mysql_query("SET names UTF8");// 4、操作数据（通过sql语句操作数据库）$str = 'select count(*) as cc from user';$result = mysql_query($str);// 5、获取数据库的结果集并解析$row = mysql_fetch_assoc($result);echo $row['cc'];// 6、释放资源并关闭数据库mysql_free_result($result);mysql_close($link); 数据库操作常用api mysql_connect() 连接数据库 mysql_select_db() 选择数据库 mysql_query() 执SQL语句 mysql_fetch_row() 以索引数组的形式返回结果 mysql_fetch_assoc() 以关联数组的形式范湖数据 mysql_fetch_array() 返回索引数组和关联数组 mysql_fetch_object() 以对象形式返回结果 mysql_free_result() 释放资源 mysql_close() 关闭连接 基本增删改查操作]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP-数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery操作]]></title>
    <url>%2F2017%2F09%2F21%2FjQuery_Class%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[jQuery操作CSS操作 功能：设置或者修改样式，操作的是style属性。 操作单个样式 12345// name：需要设置的样式名称// value：对应的样式值$obj.css(name, value);// 使用案例$('#one').css('background','gray');// 将背景色修改为灰色 设置多个样式 12345678// 参数是一个对象，对象中包含了需要设置的样式名和样式值$obj.css(obj);// 使用案例$('#one').css(&#123; 'background':'gray', 'width':'400px', 'height':'200px'&#125;); 获取样式 1234// name:需要获取的样式名称$obj.css(name);// 案例$('div').css('background-color'); 注意：获取样式操作只会返回第一个元素对应的样式值。 隐式迭代： 设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值 获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。 class操作 添加样式类 1234// name：需要添加的样式类名，注意参数不要带点.$obj.addClass(name);// 例子,给所有的div添加one的样式。$('div').addClass('one'); 移除样式类 1234// name:需要移除的样式类名$obj.removeClass('name');// 例子，移除div中one的样式类名$('div').removeClass('one'); 判断是否有某个样式类 1234// name:用于判断的样式类名，返回值为true false$obj.hasClass(name)// 例子，判断第一个div是否有one的样式类$('div').hasClass('one'); 切换样式类 1234// name:需要切换的样式类名，如果有，移除该样式，如果没有，添加该样式。$obj.toggleClass(name);// 例子$('div').toggleClass('one'); jQuery节点操作创建节点123// $(htmlStr)// htmlStr：html格式的字符串$('&lt;span-这是一个span元素&lt;/span-'); 添加节点1234append appendTo 在被选元素的结尾插入内容prepend prependTo 在被选元素的开头插入内容before 在被选元素之后插入内容after 在被选元素之前插入内容 清空节点与删除节点 empty：清空指定节点的所有元素，自身保留(清理门户) 12$('div').empty(); // 清空div的所有内容（推荐使用，会清除子元素上绑定的内容，源码）$('div').html('');// 使用html方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除。 remove：相比于empty，自身也删除（自杀） 1$('div').remove(); 克隆节点 作用：复制匹配的元素 1234// 复制$(selector)所匹配到的元素（深度复制）// cloneNode(true)// 返回值为复制的新元素，和原来的元素没有任何关系了。即修改新元素，不会影响到原来的元素。$(selector).clone(); jQuery操作属性attr操作 设置单个属性 123456// 第一个参数：需要设置的属性名// 第二个参数：对应的属性值$obj.attr(name, value);// 用法举例$('img').attr('title','哎哟，不错哦');$('img').attr('alt','哎哟，不错哦'); 设置多个属性 12345678// 参数是一个对象，包含了需要设置的属性名和属性值$obj.attr(obj)// 用法举例$('img').attr(&#123; title:'哎哟，不错哦', alt:'哎哟，不错哦', style:'opacity:.5'&#125;); 获取属性 12345// 传需要获取的属性名称，返回对应的属性值$obj.attr(name)// 用法举例var oTitle = $('img').attr('title');alert(oTitle); 移除属性 1234// 参数：需要移除的属性名，$obj.removeAttr(name);// 用法举例$('img').removeAttr('title'); prop操作 在jQuery1.6之后，对于checked、selected、disabled这类boolean类型的属性来说，不能用attr方法，只能用prop方法。 1234// 设置属性$(':checked').prop('checked',true);// 获取属性$(':checked').prop('checked');// 返回true或者false val()/text/()html()123$obj.val() 获取或者设置表单元素的value属性的值$obj.html() 对应innerHTML$obj.text() 对应innerText/textContent，处理了浏览器的兼容性 jQuery尺寸和位置操作width方法与height方法 设置或者获取高度，不包括内边距、边框和外边距 1234// 带参数表示设置高度$('img').height(200);// 不带参数获取高度$('img').height(); 获取网页的可视区宽高 1234// 获取可视区宽度$(window).width();// 获取可视区高度$(window).height(); innerWidth/innerHeight/outerWidth/outerHeight123innerWidth()/innerHeight() 方法返回元素的宽度/高度（包括内边距）。outerWidth()/outerHeight() 方法返回元素的宽度/高度（包括内边距和边框）。outerWidth(true)/outerHeight(true) 方法返回元素的宽度/高度（包括内边距、边框和外边距）。 scrollTop与scrollLeft 设置或者获取垂直滚动条的位置 1234// 获取页面被卷曲的高度$(window).scrollTop();// 获取页面被卷曲的宽度$(window).scrollLeft(); offset方法与position方法 offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素(offsetParent)的位置。 1234// 获取元素距离document的位置,返回值为对象：&#123;left:100, top:100&#125;$(selector).offset();// 获取相对于其最近的有定位的父元素的位置。$(selector).position();]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery操作元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源代码管理工具git]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%BA%90%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[什么是源代码管理工具1. 早期源代码通过拷贝粘贴来管理 1. 不方便相互之间获取别人写的代码 2. 两个或者多个人同时修改了一个文件 是否替换 代码会冲突 3. 最终如何解决 ，需要严格约束写代码人员不要同时改一个文件 （如果同一个文件有新增的代码 让项目项目经理负责修改 ） 项目整合也是靠项目整合 2. 为了解决源代码管理的问题 就出现了源代码管理工具 1. 方便快捷的获取到别人写的代码 2. 如何解决冲突的问题 使用工具提交 如果有冲突 会同时保留两个人写的代码 git和svn的区别1．SVN优缺点优点：1、 管理方便，逻辑明确，符合一般人思维习惯。2、 易于管理，集中式服务器更能保证安全性。3、 代码一致性非常高。4、 适合开发人数不多的项目开发。缺点：1、 服务器压力太大，数据库容量暴增。2、 如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。3、 不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。 2．Git优缺点优点：1、适合分布式开发，强调个体。2、公共服务器压力和数据量都不会太大。3、速度快、灵活。4、任意两个开发者之间可以很容易的解决冲突。5、离线工作。缺点：1、学习周期相对而言比较长。2、不符合常规思维。3、代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。 svn比较适合后台项目 代码是私有的 git比较适合前端项目 代码的公开的 GIT1. 什么是GIT 是一个源代码管理工具 GIT是Linux之父当年为了维护管理Linux的源代码写的一个工具 Git 之前 很多使用 svn vss tfs hs …… https://guides.github.com/ github是一个git仓库的托管平台 代码库的平台 2. 安装GIT git命令行工具 基于git命令行的一个客户端软件（提供一个界面去管理源代码） 3. GIT命令操作 初始化一个本地GIT仓储 12cd 当前项目目录git init // 初始化一个本地的仓库 就是在本地文件夹中添加了一个.git的文件夹用于记录所有的项目变更信息 查看本地仓储的变更状态 1234git status用于查看本地仓储的状态第一次查看，显示的是一坨没有被跟踪的文件git status -s // -s 是输出简要的变更日志 添加本地暂存（托管）文件 123git add可以将一个没有被跟踪的文件添加到跟踪列表类似于node_modules这种性质的文件是不应该被跟踪 添加本地GIT忽略清单文件 12在代码库文件夹的根目录添加一个.gitignore文件此文件用于说明忽略的文件有哪些 提交被托管的文件变化到本地仓储 123git commit将本地的变化提交的本地的仓库文件夹归档一般在有了一个小单元的整体变化后再提交 对比差异 123456git config- 用于配置git的配置 入邮箱用户名等git diff可以用于对比当前状态和版本库中状态的变化 提交日志 123git log git log --oneline 查看简要日志可以查看提交日志 回归到指定版本 1git reset --hard 为仓储添加远端（服务器端）地址 将本地仓储的提交记录推送到远端的master分支 拉取远端master分支的更新记录到本地 回归到指定版本 git 进阶1. 分支 查看分支：git branch，当前分支会标有一个* 创建分支：git branch [分支名称] 分支中的代码，与创建那一刻主分支中的内容完全相同 切换分支：git checkout [分支名称] (简写)创建并切换分支：git checkout -b [分支名称] 合并分支：git merge [分支名称]，即：将其他分支合并到当前分支 删除分支：git branch -d [分支名称] 合并分支冲突 注意：合并分支时出现冲突只能手动处理文件，然后，再次提交12如果在一个从分支中做了修改，然后，在主分支中也做了修改。此时，将这个从分支合并到主分支的时候，就会出现合并冲突的问题！ 分支的说明 1 公司开发的项目都是由多个分支组成：主分支 + dev分支 2 项目经理新建项目仓库，所有的程序员都从这个仓库中获取代码，完成开发任务 3 项目经理：搭建设计仓库，创建master分支，以及dev分支（以及 debug分支等） 4 所有的程序员在 dev分支 上进行开发，并且还有自己维护的分支 5 程序员在分支上完成开发任务后，会提交合并请求 6 项目经理安排测试，如果没有问题了，最后才会与 master 分支合并 2. github基本使用 https://github.com/ github是一个GIT服务的提供商， 提出社交化编程 http://zoomzhao.github.io/code-guide/https://github.com/jobbole/awesome-javascript-cnhttps://github.com/jobbole/awesome-css-cn 开源中国-Git123在 GitHub 上免费托管的 Git 仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 github与git的关系 1 git 是一个版本控制工具 2 github就是一个网站，这个网站提供了 git 服务器的功能 将代码提交到远程仓库（HTTPS） 1 在本地创建仓库 git init git config 2 新建 README.md 文件，并输入任意内容 3 将 README.md 提交到本地 git add git commit 4 在github中新建仓库，并拿到仓库地址 5 使用命令 git push [仓库地址] master 提交内容到github的默认分支 6 刷新github仓库页面，在线修改 README.md 文件，并提交 7 使用命令 git pull [仓库地址] master 获取仓库中的最新内容 获取远程仓库内容 命令：git pull [仓库地址] [分支名称] 获取远程仓库最新内容 命令：git clone [仓库地址] [自定义本地仓库名] 将整个仓库克隆到本地 实例：git clone git://github.com/jquery/jquery.git myJQ 简化操作 1 git remote add origin [仓库地址] 作用：使用origin代替 仓库地址 ，方便操作 2 git push -u origin master 作用：-u参数将origin与master连在一起 3 使用简化命令 git push origin 就代替原来：”git remote add origin [仓库地址]” SSH介绍 非对称加密、公钥和私钥12345678910111213141516GitHub 需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而 Git 支持 SSH 协议，所以，GitHub 只要知道了你的公钥，就可以确认只有你自己才能推送，从而省去每次输入密码的操作。可以同时设置多个SSH key，比如：你可以在公司电脑提交需要一个key，回家后自己的电脑提交也需要一个keyssh是一种安全的传输模式github要求推送代码的用户是合法的，所以每次推送时候都要输入账号密码，用以验证你是否为合法用户，为了省去每次都要输入密码的步骤，采用shh公钥，密钥也就是你说的sshkey来验证你是否为合法用户在你的电脑生成了一个唯一的ssh公钥和私钥，公钥放到github上面，当你推送的时候，git就会匹配你的私钥是否跟github上面的公钥是配对的，正确就认为你是合法的，允许推送。sshkey可以理解为是你的身份标识，放在github上面表明你是这个项目的一个开发人员，但是别人是可以截获的，你本机的私钥别人就无法截获，sshkey就可以保证每次传输都是安全的。 将代码提交到远程仓库（SSH） 创建SSH Key：ssh-keygen -t rsa 在文件路径 C:\用户\当前用户名\ 找到 .ssh 文件夹 文件夹中有两个文件： 私钥：id_rsa 公钥：id_rsa.pub 在 github -&gt; settings -&gt; SSH and GPG keys页面中，新创建SSH key 粘贴 公钥 id_rsa.pub 内容到对应文本框中 在github中新建仓库或者使用现在仓库，拿到git@github.com:用户名/仓库名.git 此后，再次SSH方式与github“通信”，不用输入密码确认身份了 最佳实践 先获取再提交，即：先pull再push pull和fetch的区别 github搭建博客 使用github服务器的 gh-pages 分支1234567891 在本地工作目录使用git初始化 `git init`2 创建自己的博客项目3 将创建好的博客添加到暂存区 `git add [文件路径]`4 本地提交： `git commit -m &quot;第一个博客&quot;`5 创建分支：`git branch gh-pages` 分支名称固定！6 切换分支：`git checkout gh-pages`7 提交到github：`git push [github仓库地址] gh-pages`8 查看github中对应的仓库中，是不是提交到了 &quot;gh-pages&quot; 分支9 访问：&lt;github用户名&gt;.github.io/&lt;仓库名&gt;/&lt;文件名&gt;]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb]]></title>
    <url>%2F2017%2F07%2F17%2Fmongoose%E4%BD%BF%E7%94%A8%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 什么是mongodb1.1 mongodb是一种非关系型数据库特点： 免费 分布式 高并发 2. 搭建mongodb环境第一环节：开启mongodb服务 1.下载安装：mongodb安装包 2.开启mongodb服务 打开终端，进入安装包目录 在终端输入:mongod开启数据库服务 3.默认情况下开启数据库服务会报错：exception in initAndListen: 29 Data directory C:\data\db\ not found., terminating 原因：没有指定数据库存储路径 默认情况下mongodb会将数据库文件保存在安装包的磁盘根目录：例如:C:\data\db\ 4.手动在你的mongodb安装包的磁盘根目录（默认是C盘），创建data/db文件夹 5.创建完C:\data\db之后，重复步骤2，如果终端出现waiting for connections on port 27017表示配置成功 此时这个终端窗口就相当于mongodb软件，不能关闭，一旦关闭数据库无法使用 第二个环节：连接mongodb服务，相当于开启excel软件 细节：连接mongodb服务的前提是已经开启了服务 Robomongo：可视化数据库操作工具，mongodb专用的 1.安装robo3t 2.打开之后点击create创建一个链接：默认mongodb的端口是27017无需修改 3.选择连接刚刚创建的链接 3.mongodb存储数据结构 1.数据库服务：关系型：excel软件 非关系型：mongod mongosse: 一个数据库服务可以有很多个数据库 2.数据库：database 关系型：一个excel文件 非关系型：database mongoose：database 一个数据库下可以有很多张表 3.表：table 关系型：表格table 非关系型：集合collections mongoose：model 列：cloum 确定表的存储数据结构 mongoose:schema 4.一个表中可以有很多行：关系型：记录、行 非关系型：文档（Documents） mongoose:实体entity 4.数据增删改查mongoose介绍:第三方模块 特点：1.异步环境（与nodejs高性能不谋而合） 2.基于ORM（object relational Mapping）技术：对象关系映射技术(以面向对象的思维操作数据库) 说人话：通过操作对象来操作数据库（看不到sql语句，看不到数据库操作，增删改查已经变成一个对象的四个方法API） mongodb，mongod，robomongo,mongoose三者之前的关系与区别 mongodb：数据库的名字 mongod：数据库服务，要想使用数据库必须要开启服务 robomongo:数据库的客户端（有界面，使用鼠标来操作数据库的增删改查） mongoose：数据库的客户端（无界面，使用代码来操作数据库的增删改查） 5. mongoose使用完整流程 1.导入mongoose：var mongoose = require(&#39;mongoose&#39;) 2.连接数据库:mongoose.connect(&#39;mongodb://localhost/数据库名字&#39;) 3.创建Schema：var schema = mongoose.Schema({属性名：数据类型}) （1）确定数据库数据结构 （2）创建model 4.创建Model:var model = mongoose.model(模型名字,schema) 第一个参数：要创建的model名（集合collections名字） mongoose默认会将首字母小写 会以复数的形式 第二个参数 schema 5.创建Entity：var entity = new model({属性名：值}) 6.增删改查 6.mongoose实现增删改查 增加：create() 查询：find()、findOne()、findById() 修改：update()、updateMany() 删除：deleteOne()、deleteMany()]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相对长度单位]]></title>
    <url>%2F2017%2F07%2F03%2F%E7%9B%B8%E5%AF%B9%E9%95%BF%E5%BA%A6%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[相对长度单位 在移动开发过程中，因为手机的屏幕尺寸比较多， 如果使用绝对长度单位， 那么在不同的手机尺寸下面，显示的比例可能不一样。 相对长度单位说明 在css中有两个相对长度单位， em， rem。 我们可以把它理解成屏幕宽度的 一份。 1份默认的宽度是16px，也就是浏览器器的默认显示字体， 如果说直接使用16px. 是不行的， 假如说，在ipone7上和iphone7plus上，有一个元素，都占了五份。 相当于两个屏幕上都创建一个 5*16px的宽度的元素。所以，我们要根据不同的手机宽度，来设置每一份到底点多大的宽度。 设置相对长度单位，也就是一份的大小 先把屏幕的宽度拿到，分成10份， 把每一份的宽度设为 html 的 font-size 的大小，那么 1份=html.fontsize = 1em, 1rem12345&lt;script&gt; //把屏幕分成10份 var screenw = window.screen.width; document.querySelector(&quot;html&quot;).style.fontSize = screenw / 10 + &quot;px&quot;;&lt;/script&gt; 这段js代码要写在最上面 到底是使用rem还是em？ rem永远是html的font-size的大小作为一份的大小；em是以父元素的font-size的大小作为一份的大小。 我们那建议为了减少计算量，直接使用 rem rem和em都是相对长度单位 rem是相对于根元素的font-size来算出每一份的宽度 em是相对于父元素的font-size的大小算出每一份的宽度 如何使用rem 设计人员会给我们一种尺寸的设计图 它是用 px 来标记的 一般给的是高清图（以设备的分辨率作为宽高，而不是以css宽度），我们需要把它转成 css 宽度 （640 / 2 = 320） 除了二倍图之外，也可能给3倍图， 如果3倍图，就要除以3 算出每个 px 在设计人员给的这个屏幕尺寸下的 rem的值。转rem的规则都是一样的 算出在当前屏幕尺寸下的 1rem值是多少。 320 / 10 = 32px 假如说，它标记了某个字体是 24px 对应我们在开发中要用的 那个值是 rem = 24px/32px]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery选择器]]></title>
    <url>%2F2017%2F06%2F21%2FjQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[选择器jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery选择器返回的是jQuery对象。 jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多更加复杂的选择器。（查看jQuery文档） jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。所以我们平时真正能用到的只是少数的最常用的选择器。 jQuery基本选择器 名称 用法 描述 ID选择器 $(‘#id’); 获取指定ID的元素 类选择器 $(‘.class’); 获取同一类class的元素 标签选择器 $(‘div’); 获取同一类标签的所有元素 并集选择器 $(‘div,p,li’); 使用逗号分隔，只要符合条件之一就可。 交集选择器 $(‘div.redClass’); 获取class为redClass的div元素 总结：跟css的选择器用法一模一样。 jQuery层级选择器 名称 用法 描述 子代选择器 $(‘ul &gt; li’); 使用-号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 后代选择器 $(‘ul li’); 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等 跟CSS的选择器一模一样。 jQuery过滤选择器 这类选择器都带冒号: 名称 用法 描述 :eq（index） $(‘li:eq(2)’).css(‘color’, ‘red’); 获取到的li元素中，选择索引号为2的元素，索引号index从0开始。 :odd $(‘li:odd’).css(‘color’, ‘red’); 获取到的li元素中，选择索引号为奇数的元素 :even $(‘li:even’).css(‘color’, ‘red’); 获取到的li元素中，选择索引号为偶数的元素 jQuery筛选选择器(方法) 筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。 名称 用法 描述 children(selector) $(‘ul’).children(‘li’) 相当于$(‘ul-li’)，子类选择器 find(selector) $(‘ul’).find(‘li’); 相当于$(‘ul li’),后代选择器 siblings(selector) $(‘#first’).siblings(‘li’); 查找兄弟节点，不包括自己本身。 parent() $(‘#first’).parent(); 查找父亲 eq(index) $(‘li’).eq(2); 相当于$(‘li:eq(2)’),index从0开始 next() $(‘li’).next() 找下一个兄弟 prev() $(‘li’).prev() 找上一次兄弟]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js贪吃蛇]]></title>
    <url>%2F2017%2F05%2F28%2F%E7%AE%80%E6%98%93%E8%B4%AA%E5%90%83%E8%9B%87%2F</url>
    <content type="text"><![CDATA[简易贪吃蛇项目分析 原理：我只要找一个对象，当我调用它开始游戏的方法，那么游戏就开始了。但是现在没有这样的对象，所以我们要封装这个对象，相当于是一个游戏管家。 确定开发步骤 写一个div到body里，当地图，设置样式宽和高、背景颜色、相对定位 创建食物 创建蛇 把食物和蛇单独封装到各自的一个文件 创建一个游戏管家类 用户按上下左右让蛇跟着动 判断越界 判断吃食物 创建地图模板1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #map &#123; width: 600px; height: 600px; background-color: #cccccc; position: relative; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;map&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;food.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;snake.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;Game.js&quot;&gt;&lt;/script&gt;&lt;script&gt;//找到地图var map = document.getElementById(&quot;map&quot;);//实例化游戏管家对象var gm = new Game();gm.startGame(map);&lt;/script&gt; 创建食物1234567891011121314151617181920212223242526272829303132333435363738function Food(x, y, w, h, color) &#123; this.x = x || 0; this.y = y || 0; this.width = w || 20; this.height = h || 20; this.color = color || &quot;green&quot;;&#125;var lastFood;//把食物渲染出来Food.prototype.render = function (map) &#123;if (lastFood) &#123; //先把上一次的食物清掉 map.removeChild(lastFood);&#125; //用地图的宽除以食物的宽得到最大可以放多少列 var col = map.offsetWidth / this.width; this.x = Math.floor((Math.random() * col)) * this.width; var row = map.offsetHeight / this.height; this.y = Math.floor(Math.random() * row) * this.height; //创建div var div = document.createElement(&quot;div&quot;); div.style.position = &quot;absolute&quot;; div.style.left = this.x + &quot;px&quot;; div.style.top = this.y + &quot;px&quot;; div.style.width = this.width + &quot;px&quot;; div.style.height = this.height + &quot;px&quot;; div.style.backgroundColor = this.color; lastFood = div; map.appendChild(div); &#125; 创建蛇对象//保存上一次渲染生成的div var list = []; //因为蛇是对象，所以给它一个构造函数 function Snake(bodyW, bodyH, direction) { //宽和高，只要用一个属性保存 this.bodyW = bodyW || 20; this.bodyH = bodyH || 20; //这里可以设置蛇默认的方向 this.direction = direction || &quot;right&quot;; //蛇有身体，身体由数组组成（因为默认有3节身体，后面吃了食物还要能长身体（相当于给数组加一个元素）） this.body = [ {x: 3, y: 1, color: &quot;red&quot;}, {x: 2, y: 1, color: &quot;seagreen&quot;}, {x: 1, y: 1, color: &quot;seagreen&quot;}, ]; } Snake.prototype.render = function (map) { //先删除上一次渲染出来的div for (var i = 0; i &lt; list.length; i++) { map.removeChild(list[i]); } //内存中也要把这些div清楚掉 list = []; //body里有多少个元素，就创建多少个div for (var i = 0; i &lt; this.body.length; i++) { var div = document.createElement(&quot;div&quot;); div.style.position = &quot;absolute&quot;; div.style.left = this.body[i].x * this.bodyW + &quot;px&quot;; div.style.top = this.body[i].y * this.bodyH + &quot;px&quot;; div.style.width = this.bodyW + &quot;px&quot;; div.style.height = this.bodyH + &quot;px&quot;; div.style.backgroundColor = this.body[i].color; //把每次创建的div保存起来 list.push(div); map.appendChild(div); } } //移动是蛇的行为，所以给蛇对象加一个移动的方法 Snake.prototype.move = function () { //蛇身体移动，它前一个位置是多少，它就移动到多少 //从后到前遍历会更好，因为这样的话前一个身体还没动过位置可以拿到这个位置 //注意：不要包括0，因为0是蛇头，而蛇头没有前一个身体，是要单独根据方向来定 for (var i = this.body.length - 1; i &gt; 0; i--) { this.body[i].x = this.body[i - 1].x; this.body[i].y = this.body[i - 1].y; } //蛇头移动根据方向来 switch (this.direction) { case &quot;up&quot;: this.body[0].y--; break; case &quot;down&quot;: this.body[0].y++; break; case &quot;left&quot;: this.body[0].x--; break; case &quot;right&quot;: this.body[0].x++; break; } } 创建一个游戏管家类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117var that;function Game() &#123; //把游戏管理者对象保存起来，保存在that that = this; //管理蛇对象 this.snake = new Snake(); //管理食物对象 this.food = new Food();&#125;function bindKey() &#123; //document.onkeypress;//不包括功能键 document.onkeydown = function (e) &#123; e = e || window.event; var code = e.keyCode || e.charCode || e.which; //37左 38上 39右 40下 switch (code) &#123; case 37: if (that.snake.direction != &quot;right&quot;) that.snake.direction = &quot;left&quot;; break; case 38: if (that.snake.direction != &quot;down&quot;) that.snake.direction = &quot;up&quot;; break; case 39: if (that.snake.direction != &quot;left&quot;) that.snake.direction = &quot;right&quot;; break; case 40: if (that.snake.direction != &quot;up&quot;) that.snake.direction = &quot;down&quot;; break; &#125; &#125;&#125;//开始游戏Game.prototype.startGame = function (map) &#123; //开始游戏时就需要监听网页用户按下的键 bindKey(); //要把食物画出来 this.food.render(map); //把蛇画出来 this.snake.render(map); //蛇自己自动 autoMove();&#125;function autoMove() &#123; var timerID = setInterval(function () &#123; //保存移动之前最后一格的身体坐标（为了如果移动后吃到食物了，这个坐标就给新添加的身体） var oldX = that.snake.body[that.snake.body.length - 1].x; var oldY = that.snake.body[that.snake.body.length - 1].y; //让蛇自己动 that.snake.move(); //判断是否越界 //如果水平方向一行只能放20个，意味着蛇头的x如果大于等于20就越界 var maxCol = map.offsetWidth / that.snake.bodyW; var maxRow = map.offsetHeight / that.snake.bodyH; var head = that.snake.body[0]; if (head.x &gt;= maxCol || head.x &lt; 0 || head.y &lt; 0 || head.y &gt;= maxRow) &#123; alert(&quot;Game Over!&quot;); clearInterval(timerID); return; &#125; //判断有没有吃到食物：思路：蛇头的坐标如果和食物的坐标重合就代表吃到了 //先计算出蛇头真正left值 var x = head.x * that.snake.bodyW; //再计算蛇头真正的top值 var y = head.y * that.snake.bodyH; //判断是否迟到食物 if (x == that.food.x &amp;&amp; y == that.food.y) &#123; //让蛇加一节身体 that.snake.body.push( &#123;x: oldX, y: oldY, color: &quot;seagreen&quot;&#125; ) //让食物重新生成（渲染）它内部每次渲染之前都清除原来的了 that.food.render(map); &#125; //让你根据最新位置渲染 that.snake.render(map); &#125;, 180);&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器工作原理]]></title>
    <url>%2F2017%2F04%2F25%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浏览器工作原理1.1-浏览器的组成 1.人机交互(用户界面UI) 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分 2.浏览器引擎（Rendering engine） 用来查询及操作渲染引擎的接口,也被称为浏览器内核、渲染引起，主要负责取得页面内容、整理信息（应用CSS）、计算页面的显示方式，然后会输出到显示器或者打印机 3.渲染引擎 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来 4.网络请求部分(Socket)－用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作 5.UI后端 *用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口 6.JavaScript引擎部分(JS解释器) 用来解释执行JS代码 7.数据存储 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术 1.2-主流渲染引擎1.2.1-介绍 1.渲染引擎 又叫 排版引擎 或 浏览器内核。 2.主流的 渲染引擎 有 Chrome浏览器: Blink引擎（WebKit的一个分支）。 Safari浏览器: WebKit引擎，windows版本2008年3月18日推出正式版，但苹果已于2012年7月25日停止开发Windows版的Safari。 FireFox浏览器: Gecko引擎。 Opera浏览器: Blink引擎(早期版使用Presto引擎）。 Internet Explorer浏览器: Trident引擎。 Microsoft Edge浏览器: EdgeHTML引擎（Trident的一个分支）。 1.2.2-工作原理 1.解析HTML构建Dom树（Document Object Model，文档对象模型），DOM 是W3C组织推荐的处理可扩展置标语言的标准编程接口。 2.构建渲染树，渲染树并不等同于Dom树，因为像head标签 或 display: none这样的元素就没有必要放到渲染树中了，但是它们在Dom树中。 3.对渲染树进行布局，定位坐标和大小、确定是否换行、确定position、overflow、z-index等等，这个过程叫&quot;layout&quot; 或 &quot;reflow&quot;。 4.绘制渲染树，调用操作系统底层API进行绘图操作。 渲染引擎工作原理示意图 WebKit工作原理（Chrome、Safari、Opera） Gecko工作原理（FireFox） 浏览器的 reflow 或 layout 过程https://www.youtube.com/watch?v=ZTnIxIA5KGw 打开 Chrome 的 Rendering 功能第一步： 第二步： 浏览器访问网站过程 在浏览器地址栏中输入网址。 浏览器通过用户在地址栏中输入的URL构建HTTP请求报文。 123456789GET / HTTP/1.1Host: www.taobao.comConnection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding: gzip, deflate, sdch, brAccept-Language: zh-CN,zh;q=0.8,en;q=0.6Cookie: l=Ag0NWp9E8X4hgaGEtIBhOmKxnSOH6kG8; isg=AkZGLTL-Yr9tHDZbgd5bsn4Rlzwg5IphaK-1BzBvMmlEM-ZNmDfacSyDfdgF; thw=cn 浏览器发起DNS解析请求，将域名转换为IP地址。 浏览器将请求报文发送给服务器。 服务器接收请求报文，并解析。 服务器处理用户请求，并将处理结果封装成HTTP响应报文。 1234567891011121314151617181920212223242526272829303132333435HTTP/1.1 200 OKServer: TengineDate: Thu, 13 Apr 2017 02:24:25 GMTContent-Type: text/html; charset=utf-8Transfer-Encoding: chunkedConnection: keep-aliveVary: Accept-EncodingVary: Ali-Detector-Type, X-CIP-PTCache-Control: max-age=0, s-maxage=300Via: cache8.l2cm10-1[172,200-0,C], cache13.l2cm10-1[122,0], cache3.cn206[0,200-0,H], cache6.cn206[0,0]Age: 293X-Cache: HIT TCP_MEM_HIT dirn:-2:-2X-Swift-SaveTime: Thu, 13 Apr 2017 02:19:32 GMTX-Swift-CacheTime: 300Timing-Allow-Origin: *EagleId: 9903e7e514920502659594264eStrict-Transport-Security: max-age=31536000Content-Encoding: gzip&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;&lt;meta charset="utf-8" /&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt;&lt;meta name="renderer" content="webkit" /&gt;&lt;title&gt;淘宝网 - 淘！我喜欢&lt;/title&gt;&lt;meta name="spm-id" content="a21bo" /&gt;&lt;meta name="description" content="淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！" /&gt;&lt;meta name="aplus-xplug" content="NONE"&gt;&lt;meta name="keyword" content="淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺" /&gt;&lt;/head&gt;&lt;body&gt;......&lt;/body&gt;&lt;/html&gt; 服务器将HTTP响应报文发送给浏览器。 浏览器接收服务器响应的HTTP报文，并解析。 浏览器解析 HTML 页面并展示，在解析HTML页面时遇到新的资源需要再次发起请求。 最终浏览器展示出了页面 windows 下 hosts 文件位置C:\Windows\System32\drivers\etc\hosts DOM 解析参考代码: 123456&lt;html&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;div&gt; &lt;img src="example.png" alt="example"/&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Webkit CSS 解析 How Browsers work - 浏览器是如何工作的How Browsers workhttps://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass 高级语法补充]]></title>
    <url>%2F2017%2F04%2F17%2FSass%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[sass 高级语法补充1. 继承12345678 .class1 &#123; border: 1px solid #ddd; &#125; .class2 &#123; @extend .class1; font-size:120%; &#125; 2. 混入1234567@mixin roundborder($myborder: 10px) &#123; border-radius: $myborder;&#125;.box &#123; @include roundborder(25px);&#125; //custom：自定义的，定制的12345678910111213141516171819202122@mixin customdiv ($sizew: 100px, $sizeh: 100px, $bgco: red, $bdr: 15px) &#123; border-radius: $bdr; width: $sizew; height: $sizeh; background-color: $bgco;&#125;.box1 &#123; position: relative; @extend .box;&#125;.little1 &#123; @include customdiv(120px, 120px, tomato, 20px);&#125;.little2 &#123; position: absolute; bottom: 0; right: 0; @include customdiv(80px*0.5, 80px+15px, skyblue, 10px); &#125; 3. 计算12345 body &#123; margin: (14px/2); top: 50px + 100px; right: $var * 10%; &#125; 4. 函数1234567 @function double($n) &#123; @return $n * 2; &#125; #sidebar &#123; width: double(5px); &#125; 5. 判断和循环12345678910//1 to 8 大于等于1，小于8@for $i from 1 to 8 &#123; &amp;.slide0#&#123;$i&#125; &#123; background: url("../images/02-head-icons/0#&#123;$i&#125;.jpg") no-repeat top left / 100% 100%; @if $i &gt; 5 &#123; border: 3px solid #000; &#125; &#125;&#125; #less 1. less的安装与使用npm install -g less 2. 变量12345678910111213141516@background-color: #ffffff;@text-color: #1A237E;p&#123; background-color: @background-color; color: @text-color; padding: 15px;&#125;ul&#123; background-color: @background-color;&#125;li&#123; color: @text-color;&#125; 3. 混入12345678910111213141516#circle&#123; background-color: #4CAF50; border-radius: 100%;&#125;#small-circle&#123; width: 50px; height: 50px; #circle&#125;#big-circle&#123; width: 100px; height: 100px; #circle&#125; 123456789101112131415#circle(@size: 25px)&#123; background-color: #4CAF50; border-radius: 100%; width: @size; height: @size;&#125;#small-circle&#123; #circle&#125;#big-circle&#123; #circle(100px)&#125; 4. 嵌套1234567891011ul&#123; background-color: #03A9F4; padding: 10px; list-style: none; li&#123; background-color: #fff; border-radius: 3px; margin: 10px 0; &#125;&#125; 5. 运算1234567891011121314151617@div-width: 100px;@color: #03A9F4;div&#123; height: 50px; display: inline-block;&#125;#left&#123; width: @div-width; background-color: @color - 100;&#125;#right&#123; width: @div-width * 2; background-color: @color;&#125; 6. 函数1234567891011@var: #004590;div&#123; height: 50px; width: 50px; background-color: @var; &amp;:hover&#123; background-color: fadeout(@var, 50%) &#125;&#125;]]></content>
      <categories>
        <category>sass</category>
      </categories>
      <tags>
        <tag>sass语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[懒加载的原理及使用]]></title>
    <url>%2F2017%2F03%2F19%2F%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[懒加载的原理及使用12把懒加载真正要加载的图片网址存在data-original=这个自定义属性里谁要懒加载，就用jQuery找到谁，并调用它的lazyload方法就可以了 不管图片隐藏还是显示 有src属性都会去加载 那么如果页面上有太多的图片 而且有些图片不在可视窗口内 如果加载了会影响页面的渲染页面时间 解决方案：自己控制图片的加载 当进入可视区域内容才去加载 怎么控制呢？ 通过控制src属性来控制图片加载 也就是说src先不给值，当滚到那张图片的显示区域时再加载 滚到以后再给它src的值，真正要显示图片的值 思路怎么样？ 首先默认所有的图片都不使用src属性，自定义一个属性存路径，当进入可视区域追加到src属性 使用插件 基于jquery的图片加载插件 jquery.lazyload.js 延时加载图片 插件的参数 用图片提前占位 placeholder : “img/grey.gif”,参数:placeholder,值为某一图片路径.此图片用来占据将要加载的图片的位置,待图片加载时,占位图则会隐藏 载入使用何种效果 effect : “fadeIn”,参数：effect(特效),值有show(直接显示),fadeIn(淡入),slideDown(下拉)等,常用fadeIn 提前开始加载 threshold : 200,参数:threshold,值为数字,代表页面高度.如设置为200,表示滚动条在离目标位置还有200的高度时就开始加载图片,可以做到不让用户察觉. 事件触发时才加载 event : “click”,参数:event,值有click(点击),mouseover(鼠标划过),sporty(运动的),foobar(…).可以实现鼠标莫过或点击图片才开始加载,后两个值未测试… 对某容器中的图片实现效果 container: $(”#container”),参数:container,值为某容器.lazyload默认在拉动浏览器滚动条时生效,这个参数可以让你在拉动某DIV的滚动条时依次加载其中的图片 图片排序混乱时 failurelimit : 10,参数:failurelimit,值为数字.lazyload默认在找到第一张不在可见区域里的图片时则不再继续加载,但当HTML容器混乱的时候可能出现可见区域内图片并没加载出来的情况,failurelimit意在加载N张可见区域外的图片,以避免出现这个问题.]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas小鸟游戏]]></title>
    <url>%2F2017%2F02%2F08%2F%E7%AC%A8%E7%AC%A8%E7%9A%84%E5%B0%8F%E9%B8%9F%2F</url>
    <content type="text"><![CDATA[FlapyBird游戏实现项目需要分析 天空背景是连续水平滚动的 地面背景是连续水平滚动的 管道背景是连续水平滚动的，管道的高度随机，管道充当小鸟飞行的障碍物 小鸟总是在做自由落体运动，点击会给他一个向上的速度，小鸟飞行中在扇动翅膀，小鸟上飞和下落时仰角会发生变化 小鸟掉到地上，或者撞到柱子上，则游戏结束 需要在右上角显示游戏持续的时间 项目实现分析 原理： 动画效果，其实就像是连环画， 每一帧，就相当于一张连环画。当播放连环画的速度极快，超过每秒24张每秒时，人的肉眼就会认会它是连续的动画效果。所有的视频播放原理都是这样的。 愤怒的小鸟这个demo中，每一帧，就相当于连环画的单张画面，每一张画面上，拥有的元素都是一样的，比如小鸟、天空、地面、管道。 但是在每一张连环画上， 元素的位置不一样，当前帧的元素的状态和位置，在是上一帧的元素的状态和位置基础上重新计算的 我们可以先把画一张连环画的效果实现，现用一个系统动画，画面就会动起来了，每次执行动画时，就相当于是先把画布清空，画一张新的画面上去 确定开发步骤 创建绘图模板 加载图片元素 天空背景实现 陆地背景实现 管道实现 小鸟实现 实现碰撞判断 时间统计实现 创建绘图模板 代码很简单 123456789101112131415161718192021&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #canvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas width="800" height="600" id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; var canvas = document.getElementById("canvas"); var ctx = canvas.getContext("2d");&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 加载图片元素 先用图片名，加载图片，并生成图片对象。所有的资源图片加载成功之后，才能运行游戏 代码 1234567891011121314151617181920212223function loadImage(imgNameList, callBack) &#123; //所有图片对象 var imageArr = &#123;&#125;; //计数，每加载完一张图片后，计数加1 var count = 0; //使用for循环加载所有图片 for (var i = 0; i &lt; imgNameList.length; i++) &#123; //创建一张图片，并保存到图片数组对象中 var image = new Image(); image.src = "imgs/" + imgNameList[i] + ".png"; imageArr[imgNameList[i]] = image; //当计数和imgNameList的长度一致时，代表所有图片都加载完成了 image.onload = function () &#123; count++; if (count == imgNameList.length) &#123; //完成回调（加载完图片之后，要做的事情） callBack(imageArr); &#125; &#125; &#125;&#125; 天空背景实现 天空，把两张天空拼在一起，不断修改这两张天空在画布的位置；当左边的天空滚出画布时，拼到第二张画布的后面重新画 代码 1234567891011121314151617181920function Sky (drawInfo) &#123; this.ctx = drawInfo.ctx; this.image = drawInfo.image; this.x = drawInfo.x; this.speed = 2;&#125;Sky.prototype = &#123; constructor: Sky, draw: function () &#123; //绘制天空 this.ctx.drawImage(this.image, this.x, 0, this.image.width, this.image.height); //移动坐标 this.x -= this.speed; if (this.x &lt; - this.image.width) &#123; this.x += 2 * this.image.width; &#125; &#125;&#125; 陆地背景实现 地面，和天空的原理是一样的，不同的是四张地面拼在一起 代码 123456789101112131415161718192021function Land (drawInfo) &#123; this.ctx = drawInfo.ctx; this.image = drawInfo.image; this.x = drawInfo.x; this.y = drawInfo.y; this.speed = 2;&#125;Land.prototype = &#123; constructor: Land, draw: function () &#123; //绘制天空 this.ctx.drawImage(this.image, this.x, this.y, this.image.width, this.image.height); //移动坐标 this.x -= this.speed; if (this.x &lt; - this.image.width) &#123; this.x += 4 * this.image.width; &#125; &#125;&#125; 管道实现 管道，管道是六组拼在一起，不断调整它们的位置，需要注意的是 我们同时还要计算管道的垂直方向的位置，因为管道的高度是随机的 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344function Pipe (drawInfo) &#123; this.ctx = drawInfo.ctx; this.topImage = drawInfo.topImage; this.bottomImage = drawInfo.bottomImage; this.x = drawInfo.x; this.bottom = drawInfo.bottom; this.space = drawInfo.space; this.gap = drawInfo.gap; this.speed = 2; this.canvasWidth = drawInfo.canvasWidth; this.canvasHeight = drawInfo.canvasHeight; this.topPipeHeight = 0; this.bottomPipeHeight = 0; //先计算高度 this.initHeight()&#125;Pipe.prototype = &#123; constructor: Pipe, draw: function () &#123; //画上面的管道 this.ctx.drawImage(this.topImage, this.x, 0, this.topImage.width, this.topPipeHeight); //画下面的管道 this.ctx.drawImage(this.bottomImage, this.x, this.topPipeHeight + this.space, this.topImage.width, this.bottomPipeHeight); //画两个方形 ctx.rect(this.x, 0, this.topImage.width, this.topPipeHeight); ctx.rect(this.x, this.topPipeHeight + this.space, this.topImage.width, this.bottomPipeHeight); //移动坐标 this.x -= this.speed; if (this.x &lt; - this.topImage.width) &#123; this.x = this.canvasWidth - this.topImage.width + this.gap; this.initHeight(); console.log(this.topPipeHeight); &#125; &#125;, initHeight: function() &#123; //随机计算高度 this.topPipeHeight = Math.random() * 200 + 100; this.bottomPipeHeight = this.canvasHeight-this.topPipeHeight-this.space-this.bottom; &#125;&#125; 小鸟实现 小鸟（三种状态）， 翅膀在下面，翅膀在中间，翅膀在下面，执行第一次动画时，用翅膀在上面的图片，插放第二张时，用翅膀在中间的图片; 播放第三张图片时，用翅膀在下面的图片，如果循环，小乌就动起来了 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function Bird (drawInfo) &#123; this.ctx = drawInfo.ctx; this.image = drawInfo.image; this.width = this.image.width/3; this.height = this.image.height; this.x = drawInfo.x; this.y = drawInfo.y; this.index = 0; this.speed = 0; this.aspeed = 0.0004; this.maxSpeed = 0.3; this.masAngle = 45;&#125;Bird.prototype = &#123; constructor: Bird, draw: function (deltaTime) &#123; //计算小鸟当前的位置 //改变后的速度 this.speed = this.speed + this.aspeed * deltaTime; //改变后的位移位置 this.y += this.speed * deltaTime + this.aspeed*deltaTime*deltaTime/2; //保存状态 ctx.save() //小鸟要以自己为中心旋转，所以要把参照原点改成自己 ctx.translate(this.x + this.width/2, this.y + this.height/2) //公式：当前速度/最大速度 = 当前角度/最大角度 var currenAngle = this.masAngle * this.speed / this.maxSpeed; ctx.rotate(this.angleToRadian(currenAngle)); //绘制小鸟（9参模型，中间四个，图片的切片位置和大小，后面四个，图片的绘制位置和大小） this.index += 1; this.ctx.drawImage(this.image, this.width*(this.index%3), 0, this.width, this.height, -this.width/2, -this.height/2, this.width, this.height ); ctx.restore(); &#125;, angleToRadian: function (angle) &#123; return angle / 180 * Math.PI; &#125;&#125; 实现碰撞判断 碰撞判断的原理：就是判断小鸟的坐标是否超出了画布的边缘，或者是否在管道的路径之内 判断是否超出了画布的边缘 1234//小鸟超出了画布了if(ctx.isPointInPath(bird.x + bird.width / 2, bird.y + bird.height /2))&#123; isDie = true;&#125; 判断是否在管道的路径之内 先把管道的路径绘制出来(pipe.js) 123//画两个方形 ctx.rect(this.x, 0, this.topImage.width, this.topPipeHeight); ctx.rect(this.x, this.topPipeHeight + this.space, this.topImage.width, this.bottomPipeHeight); 判断（flapyBird.html） 123if(ctx.isPointInPath(bird.x + bird.width / 2, bird.y + bird.height /2))&#123; isDie = true; &#125; 时间统计实现 获得累时间,用一下变量记录每播放一帧动画的时间(currentTime)，减去上次播放动画的时间(oldTime)，即为此帧与上一帧之间的时间差(deltaTime)；计算完时间差后，当前帧时间相对于下一帧，就变成了上一帧的时间（oldTime） 1234//计算时间currentTime = new Date();var deltaTime = currentTime - lastTime;lastTime = currentTime; 计算时分秒、位置、并且开始执行绘制操作 12345678910111213//计算时分秒totalTime += deltaTime;var seconds = Math.floor(totalTime/1000);var hour = Math.floor(seconds/3600);var minute = Math.floor(seconds%3600/60);var second = Math.floor(seconds%60);//获取文字及长度var text = "您坚持了"+hour+"小时"+minute+"分"+second+"秒"var textwh = ctx.measureText(text);//文字绘制ctx.fillText(text, canvas.width - textwh.width - 20, 20);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步和异步]]></title>
    <url>%2F2017%2F01%2F20%2F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[js编译器编译代码的流程 1.从上往下依次解析代码 2.如果是同步执行，则立即编译，直到该同步执行完毕之后才会继续编译 同步执行会阻塞线程 3.如果是异步执行，编译器不执行而是将该异步代码放入回调池中 异步不会阻塞线程 异步一定是在同步之后执行 4.编译器直到整个文件编译结束之后，再执行异步的代码 同步与异步的区别 API：异步有回调函数无返回值，同步有返回值无回调 性能：异步性能高，同步性能低 执行顺序：同步按照从上往下顺序执行，异步无序执行 线程：异步不会阻塞线程，同步会阻塞线程 异步有ajax , setTimeout]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端向后台发送请求的几种方式]]></title>
    <url>%2F2016%2F11%2F12%2F%E5%89%8D%E7%AB%AF%E5%90%91%E5%90%8E%E5%8F%B0%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前端向后台发送请求的几种方式1、 link标签的href属性 2、 script标签的src属性 3、 img标签的src属性 4、 ajax发送请求 5、 表单提交发送请求 6、 a标签的href发送请求 7、 iframe的src属性发送请求]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>发送请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GET和POST]]></title>
    <url>%2F2016%2F09%2F24%2Fget%E5%92%8Cpost%2F</url>
    <content type="text"><![CDATA[get请求 如果浏览器使用ajax发送get请求，服务器响应数据不会跳转到新界面。如果使用a标签跳转服务器响应返回会跳转到新界面 浏览器发送get请求两种方式 1.href属性可以发送get请求 2.ajax发送 本质上还是url协议的参数格式 /路径?key1=value1&amp;key2=value2 ?表示参数的开始 key=value:参数的键值对 &amp;：多个参数之间使用&amp;符号分隔 ​ ​ GET和POST的区别 get主要用于从服务器查询数据，post用于向服务器提交数据 get通过URL传递数据，post通过http请求传递数据 get传输数据量有限制，不能大于2kb,post传递的数据量较大，一般大量的数据和文件提交都是通过Post方式 get 安全性较低。容易在url中暴露数据，post安全性较高 有关 GET 请求的其他一些注释： GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 有关 POST 请求的其他一些注释： POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 POST 请求对数据长度没有要求]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>提交请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS对象]]></title>
    <url>%2F2016%2F08%2F07%2Fjs%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[JS对象为什么要有对象1234567function printPerson(name, age, sex....) &#123;&#125;// 函数的参数如果特别多的话，可以使用对象简化function printPerson(person) &#123; console.log(person.name); ……&#125; 什么是对象12345现实生活中：万物皆对象，对象是一个具体的事物，一个具体的事物就会有行为和特征。举例： 一部车，一个手机车是一类事物，门口停的那辆车才是对象 特征：红色、四个轮子 行为：驾驶、刹车 JavaScript中的对象123456JavaScript中的对象其实就是生活中对象的一个抽象JavaScript的对象是无序属性的集合。 其属性可以包含基本值、对象或函数。对象就是一组没有顺序的值。我们可以把JavaScript中的对象想象成键值对，其中值可以是数据和函数。对象的行为和特征 特征---属性 行为---方法 事物的特征在对象中用属性来表示。 事物的行为在对象中用方法来表示。 对象字面量 字面量：11 ‘abc’ true [] {}等 12345678var o = &#123; name: 'zs, age: 18, sex: true, sayHi: function () &#123; console.log(this.name); &#125;&#125;; 思考： 1如何把学生对象、老师对象、英雄对象改写成字面量的方式 对象创建方式 对象字面量 12345678var o = &#123; name: 'zs', age: 18, sex: true, sayHi: function () &#123; console.log(this.name); &#125;&#125;; new Object()创建对象 1234567var person = new Object(); person.name = 'lisi'; person.age = 35; person.job = 'actor'; person.sayHi = function()&#123; console.log('Hello,everyBody');&#125; 工厂函数创建对象 1234567891011function createPerson(name, age, job) &#123; var person = new Object(); person.name = name; person.age = age; person.job = job; person.sayHi = function()&#123; console.log('Hello,everyBody'); &#125; return person;&#125;var p1 = createPerson('张三', 22, 'actor'); 自定义构造函数 123456789function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayHi = function()&#123; console.log('Hello,everyBody'); &#125;&#125;var p1 = new Person('张三', 22, 'actor'); 属性和方法如果一个变量属于一个对象所有，那么该变量就可以称之为该对象的一个属性，属性一般是名词，用来描述事物的特征 如果一个函数属于一个对象所有，那么该函数就可以称之为该对象的一个方法，方法是动词，描述事物的行为和功能 new关键字 构造函数 ，是一种特殊的函数。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 构造函数用于创建一类对象，首字母要大写。 构造函数要和new一起使用才有意义。 new在执行时会做四件事情 1234new会在内存中创建一个新的空对象new 会让this指向这个新的对象执行构造函数 目的：给这个新对象加属性和方法new会返回这个新对象 this详解JavaScript中的this指向问题，有时候会让人难以捉摸，随着学习的深入，我们可以逐渐了解 现在我们需要掌握函数内部的this几个特点 1. 函数在定义的时候this是不确定的，只有在调用的时候才可以确定 2. 一般函数直接执行，内部this指向全局window 3. 函数作为一个对象的方法，被该对象所调用，那么this指向的是该对象 4. 构造函数中的this其实是一个隐式对象，类似一个初始化的模型，所有方法和属性都挂载到了这个隐式对象身上，后续通过new关键字来调用，从而实现实例化 对象的使用遍历对象的属性 通过for..in语法可以遍历一个对象 1234567var obj = &#123;&#125;;for (var i = 0; i &lt; 10; i++) &#123; obj[i] = i * 2;&#125;for(var key in obj) &#123; console.log(key + "==" + obj[key]);&#125; 删除对象的属性1234567function fun() &#123; this.name = 'mm';&#125;var obj = new fun(); console.log(obj.name); // mm delete obj.name;console.log(obj.name); // undefined 内置对象JavaScript中的对象分为3种：内置对象、浏览器对象、自定义对象 JavaScript 提供多个内置对象：Math/Array/Number/String/Boolean… 对象只是带有属性和方法的特殊数据类型。 学习一个内置对象的使用，只要学会其常用的成员的使用（通过查文档学习） 可以通过MDN/W3C来查询 内置对象的方法很多，我们只需要知道内置对象提供的常用方法，使用的时候查询文档。 Math对象Math对象不是构造函数，它具有数学常数和函数的属性和方法，都是以静态成员的方式提供 跟数学相关的运算来找Math中的成员（求绝对值，取整） Math 演示：Math.PI、Math.random()、Math.floor()/Math.ceil()、Math.round()、Math.abs() 、Math.max() 123456789Math.PI // 圆周率Math.random() // 生成随机数Math.floor()/Math.ceil() // 向下取整/向上取整Math.round() // 取整，四舍五入Math.abs() // 绝对值Math.max()/Math.min() // 求最大和最小值Math.sin()/Math.cos() // 正弦/余弦Math.power()/Math.sqrt() // 求指数次幂/求平方根 Date对象创建 Date 实例用来处理日期和时间。Date 对象基于1970年1月1日（世界标准时间）起的毫秒数。 12345678// 获取当前时间，UTC世界时间，距1970年1月1日（世界标准时间）起的毫秒数var now = new Date();console.log(now.valueOf()); // 获取距1970年1月1日（世界标准时间）起的毫秒数Date构造函数的参数1. 毫秒数 1498099000356 new Date(1498099000356)2. 日期格式字符串 '2015-5-1' new Date('2015-5-1')3. 年、月、日…… new Date(2015, 4, 1) // 月份从0开始 获取日期的毫秒形式 123456789var now = new Date();// valueOf用于获取对象的原始值console.log(date.valueOf()) // HTML5中提供的方法，有兼容性问题var now = Date.now(); // 不支持HTML5的浏览器，可以用下面这种方式var now = + new Date(); // 调用 Date对象的valueOf() 日期格式化方法 1234567toString() // 转换成字符串valueOf() // 获取毫秒值// 下面格式化日期的方法，在不同浏览器可能表现不一致，一般不用toDateString()toTimeString()toLocaleDateString()toLocaleTimeString() 获取日期指定部分 123456789getTime() // 返回毫秒数和valueOf()结果一样，valueOf()内部调用的getTime()getMilliseconds() getSeconds() // 返回0-59getMinutes() // 返回0-59getHours() // 返回0-23getDay() // 返回星期几 0周日 6周6getDate() // 返回当前月的第几天getMonth() // 返回月份，***从0开始***getFullYear() //返回4位的年份 如 2016 案例 写一个函数，格式化日期对象，返回yyyy-MM-dd HH:mm:ss的形式 123456789101112131415161718function formatDate(d) &#123; //如果date不是日期对象，返回 if (!d instanceof Date) &#123; return; &#125; var year = d.getFullYear(), month = d.getMonth() + 1, date = d.getDate(), hour = d.getHours(), minute = d.getMinutes(), second = d.getSeconds(); month = month &lt; 10 ? '0' + month : month; date = date &lt; 10 ? '0' + date : date; hour = hour &lt; 10 ? '0' + hour : hour; minute = minute &lt; 10 ? '0' + minute:minute; second = second &lt; 10 ? '0' + second:second; return year + '-' + month + '-' + date + ' ' + hour + ':' + minute + ':' + second;&#125; 计算时间差，返回相差的天/时/分/秒 123456789101112131415function getInterval(start, end) &#123; var day, hour, minute, second, interval; interval = end - start; interval /= 1000; day = Math.round(interval / 60 /60 / 24); hour = Math.round(interval / 60 /60 % 24); minute = Math.round(interval / 60 % 60); second = Math.round(interval % 60); return &#123; day: day, hour: hour, minute: minute, second: second &#125;&#125; Array对象 创建数组对象的两种方式 字面量方式 new Array() 1234567891011121314// 1. 使用构造函数创建数组对象// 创建了一个空数组var arr = new Array();// 创建了一个数组，里面存放了3个字符串var arr = new Array('zs', 'ls', 'ww');// 创建了一个数组，里面存放了4个数字var arr = new Array(1, 2, 3, 4);// 2. 使用字面量创建数组对象var arr = [1, 2, 3];// 获取数组中元素的个数console.log(arr.length); 检测一个对象是否是数组 instanceof Array.isArray() HTML5中提供的方法，有兼容性问题 函数的参数，如果要求是一个数组的话，可以用这种方式来进行判断 toString()/valueOf() toString() 把数组转换成字符串，逗号分隔每一项 valueOf() 返回数组对象本身 数组常用方法 演示：push()、shift()、unshift()、reverse()、sort()、splice()、indexOf() 123456789101112131415161718192021// 1 栈操作(先进后出)push()pop() //取出数组中的最后一项，修改length属性// 2 队列操作(先进先出)push()shift() //取出数组中的第一个元素，修改length属性unshift() //在数组最前面插入项，返回数组的长度// 3 排序方法reverse() //翻转数组sort(); //即使是数组sort也是根据字符，从小到大排序// 带参数的sort是如何实现的？// 4 操作方法concat() //把参数拼接到当前数组slice() //从当前数组中截取一个新的数组，不影响原来的数组，参数start从0开始,end从1开始splice() //删除或替换当前数组的某些项目，参数start, deleteCount, options(要替换的项目)// 5 位置方法indexOf()、lastIndexOf() //如果没找到返回-1// 6 迭代方法 不会修改原数组(可选)every()、filter()、forEach()、map()、some()// 7 方法将数组的所有元素连接到一个字符串中。join() 清空数组 123456// 方式1 推荐 arr = [];// 方式2 arr.length = 0;// 方式3arr.splice(0, arr.length); 案例 将一个字符串数组输出为|分割的形式，比如“刘备|张飞|关羽”。使用两种方式实现 12345678910111213141516function myJoin(array, seperator) &#123; seperator = seperator || ','; array = array || []; if (array.length == 0)&#123; return ''; &#125; var str = array[0]; for (var i = 1; i &lt; array.length; i++) &#123; str += seperator + array[i]; &#125; return str;&#125;var array = [6, 3, 5, 6, 7, 8, 0];console.log(myJoin(array, '-'));console.log(array.join('-')) 将一个字符串数组的元素的顺序进行反转。[“a”, “b”, “c”, “d”] -&gt; [ “d”,”c”,”b”,”a”]。使用两种种方式实现。提示：第i个和第length-i-1个进行交换 12345678910111213141516function myReverse(arr) &#123; if (!arr || arr.length == 0) &#123; return []; &#125; for (var i = 0; i &lt; arr.length / 2; i++) &#123; var tmp = arr[i]; arr[i] = arr[this.length - i - 1]; arr[arr.length - i - 1] = tmp; &#125; return arr;&#125;var array = ['a', 'b', 'c'];console.log(myReverse(array));console.log(array.reverse()); 工资的数组[1500, 1200, 2000, 2100, 1800],把工资超过2000的删除 123456789101112131415161718// 方式1var array = [1500,1200,2000,2100,1800];var tmpArray = [];for (var i = 0; i &lt; array.length; i++) &#123; if(array[i] &lt; 2000) &#123; tmpArray.push(array[i]); &#125;&#125;console.log(tmpArray);// 方式2var array = [1500, 1200, 2000, 2100, 1800];array = array.filter(function (item, index) &#123; if (item &lt; 2000) &#123; return true; &#125; return false;&#125;);console.log(array); [“c”, “a”, “z”, “a”, “x”, “a”]找到数组中每一个a出现的位置 1234567var array = ['c', 'a', 'z', 'a', 'x', 'a'];do &#123; var index = array.indexOf('a',index + 1); if (index != -1)&#123; console.log(index); &#125;&#125; while (index &gt; 0); 编写一个方法去掉一个数组的重复元素 12345678910111213141516171819202122232425var array = ['c', 'a', 'z', 'a', 'x', 'a'];function clear() &#123; var o = &#123;&#125;; for (var i = 0; i &lt; array.length; i++) &#123; var item = array[i]; if (o[item]) &#123; o[item]++; &#125;else&#123; o[item] = 1; &#125; &#125; var tmpArray = []; for(var key in o) &#123; if (o[key] == 1) &#123; tmpArray.push(key); &#125;else&#123; if(tmpArray.indexOf(key) == -1)&#123; tmpArray.push(key); &#125; &#125; &#125; returm tmpArray;&#125;console.log(clear(array)); 基本包装类型为了方便操作基本数据类型，JavaScript还提供了三个特殊的引用类型：String/Number/Boolean 123456789// 下面代码的问题？// s1是基本类型，基本类型是没有方法的var s1 = 'zhangsan';var s2 = s1.substring(5);// 当调用s1.substring(5)的时候，先把s1包装成String类型的临时对象，再调用substring方法，最后销毁临时对象, 相当于：var s1 = new String('zhangsan');var s2 = s1.substring(5);s1 = null; 1234567// 创建基本包装类型的对象var num = 18; //数值，基本类型var num = Number('18'); //类型转换var num = new Number(18); //基本包装类型，对象// Number和Boolean基本包装类型基本不用，使用的话可能会引起歧义。例如：var b1 = new Boolean(false);var b2 = b1 &amp;&amp; true; // 结果是什么 String对象 字符串的不可变 12345var str = 'abc';str = 'hello';// 当重新给str赋值的时候，常量'abc'不会被修改，依然在内存中// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题 创建字符串对象 1234var str = new String('Hello World');// 获取字符串中字符的个数console.log(str.length); 字符串对象的常用方法 字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串 1234567891011121314151617181920212223// 1 字符方法charAt() //获取指定位置处字符charCodeAt() //获取指定位置处字符的ASCII码str[0] //HTML5，IE8+支持 和charAt()等效// 2 字符串操作方法concat() //拼接字符串，等效于+，+更常用slice() //从start位置开始，截取到end位置，end取不到substring() //从start位置开始，截取到end位置，end取不到substr() //从start位置开始，截取length个字符// 3 位置方法indexOf() //返回指定内容在元字符串中的位置lastIndexOf() //从后往前找，只找第一个匹配的// 4 去除空白 trim() //只能去除字符串前后的空白// 5 大小写转换方法to(Locale)UpperCase() //转换大写to(Locale)LowerCase() //转换小写// 6 其它search()replace()split()fromCharCode()// String.fromCharCode(101, 102, 103); //把ASCII码转换成字符串 案例 截取字符串”我爱中华人民共和国”，中的”中华” 123var s = "我爱中华人民共和国";s = s.substr(2,2);console.log(s); “abcoefoxyozzopp”查找字符串中所有o出现的位置 123456789var s = 'abcoefoxyozzopp';var array = [];do &#123; var index = s.indexOf('o', index + 1); if (index != -1) &#123; array.push(index); &#125;&#125; while (index &gt; -1);console.log(array); 把字符串中所有的o替换成! 1234567var s = 'abcoefoxyozzopp';do &#123; s = s.replace('o', '');&#125; while (s.indexOf('o') &gt; -1);console.log(s);console.log(s.replace(/o/ig, '')); 判断一个字符串中出现次数最多的字符，统计这个次数 1234567891011121314151617181920212223var s = 'abcoefoxyozzopp';var o = &#123;&#125;;for (var i = 0; i &lt; s.length; i++) &#123; var item = s.charAt(i); if (o[item]) &#123; o[item] ++; &#125;else&#123; o[item] = 1; &#125;&#125;var max = 0;var char ;for(var key in o) &#123; if (max &lt; o[key]) &#123; max = o[key]; char = key; &#125;&#125;console.log(max);console.log(char);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css高清背景图]]></title>
    <url>%2F2016%2F07%2F18%2Fcss%E9%AB%98%E6%B8%85%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[CSS高清背景图说明 现在的手机普遍使用的都是高清图，也就意味着屏幕有两个宽度 css的像素的宽度： 在开发过程中，布局直接使用的宽度 手机硬件的分辨率的宽度，一般情况下和CSS的宽度是一致的，但是近几年，都流行高清屏，硬件的宽度一般是css宽度的2倍或3倍，这个时候就需要使用高清图片 在前端开发的时候，一般使用一个2倍图就可以了 使用 假如我们使用的就是一个小图标： 那么只需要把 background-size 设为图片本身的一半，就可以了 ´background: url(“./images/im_2x.png”) no-repeat 0px 0px /57px 21px; 如果使用的是精灵图： 那么要做的事情 把background-position:x y; 设为它本来在精灵的位置的一半。 把background-size 也设为图片本身宽度的一半。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
