<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Canvas动画]]></title>
    <url>%2F2018%2F03%2F06%2FCanvas%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[动画与变形动画原理 动画的原理，就是一张张画面连续快速播放，当速度超过每秒24张时，人的肉眼就不会分辨出卡顿感。而觉得是在播放连续的视频动画 所以， 我们要实现动画，只需要隔十几毫秒把屏幕清空之后，重新绘制下一帧就可以了 执行动画方案 我们可以用window.setInterval(), window.setTimeout(),和window.requestAnimationFrame()来设定定期执行一个指定函数。 setInterval(function, delay): 当设定好间隔时间后，function会定期执行。 setTimeout(function, delay): 在设定好的时间之后执行函数 requestAnimationFrame(callback): 递归调用的形式才实现动画，动画的频率跟随浏览器的刷新频率，效率比较高，连续动画都使用这种方式就可以了 弹球动画讲解 先实现绘制某一帧的方法(draw()) 清空canvas 绘制小球 更改小球的位置 添加一个动画(window.requesAnimationFrame(draw)) 边界处理 如果小球到达边界，修改其速度为反方向； 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;script&gt; var canvas = document.getElementById("canvas"); var ctx = canvas.getContext("2d"); ctx.fillStyle = "blue"; var animation; //创建一个圆对象 var circle = &#123; radias: 30, x: 0, y: 0, speedx: 2, speedy: 1, isRunning: false, draw: function () &#123; //画一个圆 ctx.beginPath(); ctx.arc(this.x, this.y, this.radias, 0, 2*Math.PI); ctx.fill(); &#125; &#125;; function draw() &#123; //每一帧，圆的位置都会发生变化 circle.x += circle.speedx; circle.y += circle.speedy; //边界判断，到了边界就调头 if (circle.x == canvas.width-circle.radias || circle.x == circle.radias) &#123; circle.speedx = -circle.speedx; &#125; if (circle.y == canvas.height-circle.radias || circle.y == circle.radias) &#123; circle.speedy = -circle.speedy; &#125; //绘制小球，绘制当前帧，把上一帧的画面清空 //ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.save(); ctx.fillStyle = "rgba(255,255,255,0.2)"; //ctx.fillStyle = "red"; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore(); circle.draw(); //开始执行动画 animation = window.requestAnimationFrame(draw); &#125; //添加点击事件，当点击时，如果正在运行，则暂停，如果没有正在运行，则点击动行 canvas.addEventListener("click", function (e) &#123; if (!circle.isRunning) &#123; circle.x = e.clientX; circle.y = e.clientY; animation = window.requestAnimationFrame(draw); circle.isRunning = true; &#125; else &#123; circle.isRunning = false; window.cancelAnimationFrame(animation); &#125; &#125;);&lt;/script&gt; 变形缩放 scale是用来缩放画布元素的坐标和宽高。如果一张（100*100）的画布，scale为（0.5, 0.5），用fillRect(50, 50, 50, 50)来画一个正方形，实际显示效果未缩放前的（25, 25, 25, 25）位置和大小的效果是一样的。 代码与示例 1234567891011121314151617181920212223&lt;script&gt; var canvas = document.getElementById("canvas"); var ctx = canvas.getContext("2d"); //设置画笔的粗细和颜色 ctx.lineWidth = 1; ctx.strokeStyle = "red"; //1. 将画笔移动到某个点 ctx.moveTo(0, 200); //2. 从上面这个点开始，划一条直接到某一个点 ctx.lineTo(600, 200); ctx.moveTo(300, 0); ctx.lineTo(300, 400); //3. 填充颜色 ctx.stroke(); ctx.fillRect(300, 200, 100, 100); ctx.scale(0.5, 0.5); ctx.fillRect(300, 200, 100, 100);&lt;/script&gt; 平移 平移就是改变往水平或垂直方向，改变参考原点的值。translate(100, 100);就是绘图时，在当前参考原点的基本之上，向右平移100像素，向下平移100像素。 代码与示例 1234567891011121314151617181920212223&lt;script&gt; var canvas = document.getElementById("canvas"); var ctx = canvas.getContext("2d"); //设置画笔的粗细和颜色 ctx.lineWidth = 1; ctx.strokeStyle = "red"; //1. 将画笔移动到某个点 ctx.moveTo(0, 200); //2. 从上面这个点开始，划一条直接到某一个点 ctx.lineTo(600, 200); ctx.moveTo(300, 0); ctx.lineTo(300, 400); //3. 填充颜色 ctx.stroke(); ctx.fillRect(300, 200, 100, 100); ctx.translate(100, 100); ctx.fillRect(300, 200, 100, 100);&lt;/script&gt; 旋转 旋转，就是围绕当前的原点，坐标系发生旋转。 代码与示例 12345678910111213141516171819&lt;script&gt; var canvas = document.getElementById("canvas"); var ctx = canvas.getContext("2d"); ctx.save(); ctx.translate(200, 200); //画30条直线，角度不一样 for (var i=0; i&lt;30; i++) &#123; ctx.rotate(1/15*Math.PI); ctx.beginPath(); ctx.moveTo(30, 0); ctx.lineTo(150, 0); ctx.stroke(); &#125; ctx.restore();&lt;/script&gt; ​]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM元素获取]]></title>
    <url>%2F2018%2F03%2F06%2FDOM%E5%85%83%E7%B4%A0%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[获得页面元素的方式 document.getElementById(); //方法可返回对拥有指定 ID 的第一个对象的引用 document.getElementsByTagName(); //返回带有指定标签名的对象集合。 document.getElementsByClassName(); //方法返回文档中所有指定类名的元素集合 querySelector(); //方法仅仅返回匹配指定选择器的第一个元素。如需返回所有的元素，请使用 querySelectorAll() 方法替代。 querySelectorAll()； // 是HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js贪吃蛇]]></title>
    <url>%2F2017%2F05%2F28%2F%E7%AE%80%E6%98%93%E8%B4%AA%E5%90%83%E8%9B%87%2F</url>
    <content type="text"><![CDATA[简易贪吃蛇项目分析 原理：我只要找一个对象，当我调用它开始游戏的方法，那么游戏就开始了。但是现在没有这样的对象，所以我们要封装这个对象，相当于是一个游戏管家。 确定开发步骤 写一个div到body里，当地图，设置样式宽和高、背景颜色、相对定位 创建食物 创建蛇 把食物和蛇单独封装到各自的一个文件 创建一个游戏管家类 用户按上下左右让蛇跟着动 判断越界 判断吃食物 创建地图模板1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #map &#123; width: 600px; height: 600px; background-color: #cccccc; position: relative; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;map&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;food.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;snake.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;Game.js&quot;&gt;&lt;/script&gt;&lt;script&gt;//找到地图var map = document.getElementById(&quot;map&quot;);//实例化游戏管家对象var gm = new Game();gm.startGame(map);&lt;/script&gt; 创建食物1234567891011121314151617181920212223242526272829303132333435363738function Food(x, y, w, h, color) &#123; this.x = x || 0; this.y = y || 0; this.width = w || 20; this.height = h || 20; this.color = color || &quot;green&quot;;&#125;var lastFood;//把食物渲染出来Food.prototype.render = function (map) &#123;if (lastFood) &#123; //先把上一次的食物清掉 map.removeChild(lastFood);&#125; //用地图的宽除以食物的宽得到最大可以放多少列 var col = map.offsetWidth / this.width; this.x = Math.floor((Math.random() * col)) * this.width; var row = map.offsetHeight / this.height; this.y = Math.floor(Math.random() * row) * this.height; //创建div var div = document.createElement(&quot;div&quot;); div.style.position = &quot;absolute&quot;; div.style.left = this.x + &quot;px&quot;; div.style.top = this.y + &quot;px&quot;; div.style.width = this.width + &quot;px&quot;; div.style.height = this.height + &quot;px&quot;; div.style.backgroundColor = this.color; lastFood = div; map.appendChild(div); &#125; 创建蛇对象//保存上一次渲染生成的div var list = []; //因为蛇是对象，所以给它一个构造函数 function Snake(bodyW, bodyH, direction) { //宽和高，只要用一个属性保存 this.bodyW = bodyW || 20; this.bodyH = bodyH || 20; //这里可以设置蛇默认的方向 this.direction = direction || &quot;right&quot;; //蛇有身体，身体由数组组成（因为默认有3节身体，后面吃了食物还要能长身体（相当于给数组加一个元素）） this.body = [ {x: 3, y: 1, color: &quot;red&quot;}, {x: 2, y: 1, color: &quot;seagreen&quot;}, {x: 1, y: 1, color: &quot;seagreen&quot;}, ]; } Snake.prototype.render = function (map) { //先删除上一次渲染出来的div for (var i = 0; i &lt; list.length; i++) { map.removeChild(list[i]); } //内存中也要把这些div清楚掉 list = []; //body里有多少个元素，就创建多少个div for (var i = 0; i &lt; this.body.length; i++) { var div = document.createElement(&quot;div&quot;); div.style.position = &quot;absolute&quot;; div.style.left = this.body[i].x * this.bodyW + &quot;px&quot;; div.style.top = this.body[i].y * this.bodyH + &quot;px&quot;; div.style.width = this.bodyW + &quot;px&quot;; div.style.height = this.bodyH + &quot;px&quot;; div.style.backgroundColor = this.body[i].color; //把每次创建的div保存起来 list.push(div); map.appendChild(div); } } //移动是蛇的行为，所以给蛇对象加一个移动的方法 Snake.prototype.move = function () { //蛇身体移动，它前一个位置是多少，它就移动到多少 //从后到前遍历会更好，因为这样的话前一个身体还没动过位置可以拿到这个位置 //注意：不要包括0，因为0是蛇头，而蛇头没有前一个身体，是要单独根据方向来定 for (var i = this.body.length - 1; i &gt; 0; i--) { this.body[i].x = this.body[i - 1].x; this.body[i].y = this.body[i - 1].y; } //蛇头移动根据方向来 switch (this.direction) { case &quot;up&quot;: this.body[0].y--; break; case &quot;down&quot;: this.body[0].y++; break; case &quot;left&quot;: this.body[0].x--; break; case &quot;right&quot;: this.body[0].x++; break; } } 创建一个游戏管家类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117var that;function Game() &#123; //把游戏管理者对象保存起来，保存在that that = this; //管理蛇对象 this.snake = new Snake(); //管理食物对象 this.food = new Food();&#125;function bindKey() &#123; //document.onkeypress;//不包括功能键 document.onkeydown = function (e) &#123; e = e || window.event; var code = e.keyCode || e.charCode || e.which; //37左 38上 39右 40下 switch (code) &#123; case 37: if (that.snake.direction != &quot;right&quot;) that.snake.direction = &quot;left&quot;; break; case 38: if (that.snake.direction != &quot;down&quot;) that.snake.direction = &quot;up&quot;; break; case 39: if (that.snake.direction != &quot;left&quot;) that.snake.direction = &quot;right&quot;; break; case 40: if (that.snake.direction != &quot;up&quot;) that.snake.direction = &quot;down&quot;; break; &#125; &#125;&#125;//开始游戏Game.prototype.startGame = function (map) &#123; //开始游戏时就需要监听网页用户按下的键 bindKey(); //要把食物画出来 this.food.render(map); //把蛇画出来 this.snake.render(map); //蛇自己自动 autoMove();&#125;function autoMove() &#123; var timerID = setInterval(function () &#123; //保存移动之前最后一格的身体坐标（为了如果移动后吃到食物了，这个坐标就给新添加的身体） var oldX = that.snake.body[that.snake.body.length - 1].x; var oldY = that.snake.body[that.snake.body.length - 1].y; //让蛇自己动 that.snake.move(); //判断是否越界 //如果水平方向一行只能放20个，意味着蛇头的x如果大于等于20就越界 var maxCol = map.offsetWidth / that.snake.bodyW; var maxRow = map.offsetHeight / that.snake.bodyH; var head = that.snake.body[0]; if (head.x &gt;= maxCol || head.x &lt; 0 || head.y &lt; 0 || head.y &gt;= maxRow) &#123; alert(&quot;Game Over!&quot;); clearInterval(timerID); return; &#125; //判断有没有吃到食物：思路：蛇头的坐标如果和食物的坐标重合就代表吃到了 //先计算出蛇头真正left值 var x = head.x * that.snake.bodyW; //再计算蛇头真正的top值 var y = head.y * that.snake.bodyH; //判断是否迟到食物 if (x == that.food.x &amp;&amp; y == that.food.y) &#123; //让蛇加一节身体 that.snake.body.push( &#123;x: oldX, y: oldY, color: &quot;seagreen&quot;&#125; ) //让食物重新生成（渲染）它内部每次渲染之前都清除原来的了 that.food.render(map); &#125; //让你根据最新位置渲染 that.snake.render(map); &#125;, 180);&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas小鸟游戏]]></title>
    <url>%2F2017%2F02%2F08%2F%E7%AC%A8%E7%AC%A8%E7%9A%84%E5%B0%8F%E9%B8%9F%2F</url>
    <content type="text"><![CDATA[FlapyBird游戏实现项目需要分析 天空背景是连续水平滚动的 地面背景是连续水平滚动的 管道背景是连续水平滚动的，管道的高度随机，管道充当小鸟飞行的障碍物 小鸟总是在做自由落体运动，点击会给他一个向上的速度，小鸟飞行中在扇动翅膀，小鸟上飞和下落时仰角会发生变化 小鸟掉到地上，或者撞到柱子上，则游戏结束 需要在右上角显示游戏持续的时间 项目实现分析 原理： 动画效果，其实就像是连环画， 每一帧，就相当于一张连环画。当播放连环画的速度极快，超过每秒24张每秒时，人的肉眼就会认会它是连续的动画效果。所有的视频播放原理都是这样的。 愤怒的小鸟这个demo中，每一帧，就相当于连环画的单张画面，每一张画面上，拥有的元素都是一样的，比如小鸟、天空、地面、管道。 但是在每一张连环画上， 元素的位置不一样，当前帧的元素的状态和位置，在是上一帧的元素的状态和位置基础上重新计算的 我们可以先把画一张连环画的效果实现，现用一个系统动画，画面就会动起来了，每次执行动画时，就相当于是先把画布清空，画一张新的画面上去 确定开发步骤 创建绘图模板 加载图片元素 天空背景实现 陆地背景实现 管道实现 小鸟实现 实现碰撞判断 时间统计实现 创建绘图模板 代码很简单 123456789101112131415161718192021&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #canvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas width="800" height="600" id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; var canvas = document.getElementById("canvas"); var ctx = canvas.getContext("2d");&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 加载图片元素 先用图片名，加载图片，并生成图片对象。所有的资源图片加载成功之后，才能运行游戏 代码 1234567891011121314151617181920212223function loadImage(imgNameList, callBack) &#123; //所有图片对象 var imageArr = &#123;&#125;; //计数，每加载完一张图片后，计数加1 var count = 0; //使用for循环加载所有图片 for (var i = 0; i &lt; imgNameList.length; i++) &#123; //创建一张图片，并保存到图片数组对象中 var image = new Image(); image.src = "imgs/" + imgNameList[i] + ".png"; imageArr[imgNameList[i]] = image; //当计数和imgNameList的长度一致时，代表所有图片都加载完成了 image.onload = function () &#123; count++; if (count == imgNameList.length) &#123; //完成回调（加载完图片之后，要做的事情） callBack(imageArr); &#125; &#125; &#125;&#125; 天空背景实现 天空，把两张天空拼在一起，不断修改这两张天空在画布的位置；当左边的天空滚出画布时，拼到第二张画布的后面重新画 代码 1234567891011121314151617181920function Sky (drawInfo) &#123; this.ctx = drawInfo.ctx; this.image = drawInfo.image; this.x = drawInfo.x; this.speed = 2;&#125;Sky.prototype = &#123; constructor: Sky, draw: function () &#123; //绘制天空 this.ctx.drawImage(this.image, this.x, 0, this.image.width, this.image.height); //移动坐标 this.x -= this.speed; if (this.x &lt; - this.image.width) &#123; this.x += 2 * this.image.width; &#125; &#125;&#125; 陆地背景实现 地面，和天空的原理是一样的，不同的是四张地面拼在一起 代码 123456789101112131415161718192021function Land (drawInfo) &#123; this.ctx = drawInfo.ctx; this.image = drawInfo.image; this.x = drawInfo.x; this.y = drawInfo.y; this.speed = 2;&#125;Land.prototype = &#123; constructor: Land, draw: function () &#123; //绘制天空 this.ctx.drawImage(this.image, this.x, this.y, this.image.width, this.image.height); //移动坐标 this.x -= this.speed; if (this.x &lt; - this.image.width) &#123; this.x += 4 * this.image.width; &#125; &#125;&#125; 管道实现 管道，管道是六组拼在一起，不断调整它们的位置，需要注意的是 我们同时还要计算管道的垂直方向的位置，因为管道的高度是随机的 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344function Pipe (drawInfo) &#123; this.ctx = drawInfo.ctx; this.topImage = drawInfo.topImage; this.bottomImage = drawInfo.bottomImage; this.x = drawInfo.x; this.bottom = drawInfo.bottom; this.space = drawInfo.space; this.gap = drawInfo.gap; this.speed = 2; this.canvasWidth = drawInfo.canvasWidth; this.canvasHeight = drawInfo.canvasHeight; this.topPipeHeight = 0; this.bottomPipeHeight = 0; //先计算高度 this.initHeight()&#125;Pipe.prototype = &#123; constructor: Pipe, draw: function () &#123; //画上面的管道 this.ctx.drawImage(this.topImage, this.x, 0, this.topImage.width, this.topPipeHeight); //画下面的管道 this.ctx.drawImage(this.bottomImage, this.x, this.topPipeHeight + this.space, this.topImage.width, this.bottomPipeHeight); //画两个方形 ctx.rect(this.x, 0, this.topImage.width, this.topPipeHeight); ctx.rect(this.x, this.topPipeHeight + this.space, this.topImage.width, this.bottomPipeHeight); //移动坐标 this.x -= this.speed; if (this.x &lt; - this.topImage.width) &#123; this.x = this.canvasWidth - this.topImage.width + this.gap; this.initHeight(); console.log(this.topPipeHeight); &#125; &#125;, initHeight: function() &#123; //随机计算高度 this.topPipeHeight = Math.random() * 200 + 100; this.bottomPipeHeight = this.canvasHeight-this.topPipeHeight-this.space-this.bottom; &#125;&#125; 小鸟实现 小鸟（三种状态）， 翅膀在下面，翅膀在中间，翅膀在下面，执行第一次动画时，用翅膀在上面的图片，插放第二张时，用翅膀在中间的图片; 播放第三张图片时，用翅膀在下面的图片，如果循环，小乌就动起来了 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function Bird (drawInfo) &#123; this.ctx = drawInfo.ctx; this.image = drawInfo.image; this.width = this.image.width/3; this.height = this.image.height; this.x = drawInfo.x; this.y = drawInfo.y; this.index = 0; this.speed = 0; this.aspeed = 0.0004; this.maxSpeed = 0.3; this.masAngle = 45;&#125;Bird.prototype = &#123; constructor: Bird, draw: function (deltaTime) &#123; //计算小鸟当前的位置 //改变后的速度 this.speed = this.speed + this.aspeed * deltaTime; //改变后的位移位置 this.y += this.speed * deltaTime + this.aspeed*deltaTime*deltaTime/2; //保存状态 ctx.save() //小鸟要以自己为中心旋转，所以要把参照原点改成自己 ctx.translate(this.x + this.width/2, this.y + this.height/2) //公式：当前速度/最大速度 = 当前角度/最大角度 var currenAngle = this.masAngle * this.speed / this.maxSpeed; ctx.rotate(this.angleToRadian(currenAngle)); //绘制小鸟（9参模型，中间四个，图片的切片位置和大小，后面四个，图片的绘制位置和大小） this.index += 1; this.ctx.drawImage(this.image, this.width*(this.index%3), 0, this.width, this.height, -this.width/2, -this.height/2, this.width, this.height ); ctx.restore(); &#125;, angleToRadian: function (angle) &#123; return angle / 180 * Math.PI; &#125;&#125; 实现碰撞判断 碰撞判断的原理：就是判断小鸟的坐标是否超出了画布的边缘，或者是否在管道的路径之内 判断是否超出了画布的边缘 1234//小鸟超出了画布了if(ctx.isPointInPath(bird.x + bird.width / 2, bird.y + bird.height /2))&#123; isDie = true;&#125; 判断是否在管道的路径之内 先把管道的路径绘制出来(pipe.js) 123//画两个方形 ctx.rect(this.x, 0, this.topImage.width, this.topPipeHeight); ctx.rect(this.x, this.topPipeHeight + this.space, this.topImage.width, this.bottomPipeHeight); 判断（flapyBird.html） 123if(ctx.isPointInPath(bird.x + bird.width / 2, bird.y + bird.height /2))&#123; isDie = true; &#125; 时间统计实现 获得累时间,用一下变量记录每播放一帧动画的时间(currentTime)，减去上次播放动画的时间(oldTime)，即为此帧与上一帧之间的时间差(deltaTime)；计算完时间差后，当前帧时间相对于下一帧，就变成了上一帧的时间（oldTime） 1234//计算时间currentTime = new Date();var deltaTime = currentTime - lastTime;lastTime = currentTime; 计算时分秒、位置、并且开始执行绘制操作 12345678910111213//计算时分秒totalTime += deltaTime;var seconds = Math.floor(totalTime/1000);var hour = Math.floor(seconds/3600);var minute = Math.floor(seconds%3600/60);var second = Math.floor(seconds%60);//获取文字及长度var text = "您坚持了"+hour+"小时"+minute+"分"+second+"秒"var textwh = ctx.measureText(text);//文字绘制ctx.fillText(text, canvas.width - textwh.width - 20, 20);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
</search>
